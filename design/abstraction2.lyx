#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble



\newif\ifDraft\Draftfalse
%\Drafttrue


%\usepackage{scrartcl}

\usepackage{fancyhdr}\usepackage{times}\usepackage{amsthm}\usepackage{cite}


\usepackage[final,formats]{listings}

\newcommand{\src}[1]{\texttt{#1}}
\newcommand{\todo}[1]{\textit{\textbf{TODO: #1}}}

\newtheorem{proposition}{Proposition}


\title{Three-Valued Abstraction Refinement for Driver Synthesis}

\author{Leonid Ryzhyk}


\date{\today}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Three-Valued Abstraction Refinement for Driver Synthesis
\end_layout

\begin_layout Section
Concrete games
\end_layout

\begin_layout Subsection
Games
\end_layout

\begin_layout Standard
A 
\emph on
reachability game 
\emph default

\begin_inset Formula $G=\langle S,I,\Phi,\delta_{c},\delta_{u},\gamma\rangle$
\end_inset

 consists of:
\end_layout

\begin_layout Itemize
a state space 
\begin_inset Formula $S$
\end_inset

 partitioned into controllable states 
\begin_inset Formula $S_{c}$
\end_inset

 and uncontrollable states 
\begin_inset Formula $S_{u}$
\end_inset

, 
\begin_inset Formula $S_{c}\uplus S_{u}=S$
\end_inset

,
\end_layout

\begin_layout Itemize
a set of initial states 
\begin_inset Formula $I\subseteq S$
\end_inset

, 
\end_layout

\begin_layout Itemize
a set of fair regions 
\begin_inset Formula $\Phi\subseteq2^{S_{u}}\setminus\{\emptyset\}$
\end_inset

,
\end_layout

\begin_layout Itemize
a controllable transition relation 
\begin_inset Formula $\delta_{c}\subseteq S_{c}\times S$
\end_inset

,
\end_layout

\begin_layout Itemize
an uncontrollable transition relation 
\begin_inset Formula $\delta_{u}\subseteq S_{u}\times S$
\end_inset

,
\end_layout

\begin_layout Itemize
a set of goal states 
\begin_inset Formula $\gamma\subseteq S$
\end_inset

.
\end_layout

\begin_layout Standard
We assume that the environment can remain idle in every state, i.e 
\begin_inset Formula $\forall s\in S_{u}.\,(s,s)\in\delta_{u}$
\end_inset

.
\end_layout

\begin_layout Standard
The game objective is: 
\begin_inset Formula 
\[
\bigwedge_{\varphi\in\Phi}GF\varphi\rightarrow F\gamma
\]

\end_inset


\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
The above model is simpler than our previous model based on states and labels.
 First, it does not have labels (they become part of the state, as explained
 below).
 Second, it is a strictly turn-based game, where only one of the players
 can perform a move in each state.
 These simplifications will lead to simpler abstraction and synthesis algorithms.
 At the same time, this model allows capturing the nature of the interaction
 between the driver and the environment more precisely.
\end_layout

\begin_layout Standard
We briefly describe how a TSL2 specification can be encoded as a turn-based
 game.
 The state space of the game consists of all TSL variables and arguments
 of controllable and uncontrollable tasks.
 Every command issued by the driver to the device consists of two transitions.
 The first transition 
\emph on
issues
\emph default
 the command, i.e., assigns its arguments.
 The second transition 
\emph on
executes
\emph default
 the command.
 The two transitions can be separated by several transitions tiggered by
 other processes.
 Note that in a concrete game values of command arguments remain unchanged
 between the first and the second transitions.
 This is not necessarily true in an abstract game.
\end_layout

\begin_layout Paragraph
Example
\end_layout

\begin_layout Standard
Consider a controllable task 
\family typewriter
write8
\family default
 defined as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

task controllable void write8(addr, val)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   // body of the task
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This task can be invoked either manually by writing the following line in
 the driver template
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

write8(REG1_ADDR, 0);
\end_layout

\end_inset

or automatically, from synthesised code.
 In the former case the following uncontrollable transition is generated
 for the task invocation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

assume(controllable==false); // only available when the environment has
 control
\end_layout

\begin_layout Plain Layout

write8_addr = REG1_ADDR;
\end_layout

\begin_layout Plain Layout

write8_val = 0;
\end_layout

\begin_layout Plain Layout

tag = write8;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the latter case, the controllable transition can be encoded as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

assert((magic==true)&&(controllable==true)); // only available when running
 in a magic block and when the driver has control
\end_layout

\begin_layout Plain Layout

tag = write8;
\end_layout

\begin_layout Plain Layout

write8_addr = *;		// value to be chosen by the synthesis algorithm
\end_layout

\begin_layout Plain Layout

write8_val = *;		 // value to be chosen by the synthesis algorithm
\end_layout

\begin_layout Plain Layout

tag = write8;
\end_layout

\begin_layout Plain Layout

controllable=false;	 // return control to the environments
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Regardless of how the command was issued, the actual 
\family typewriter
write8
\family default
 operation is an uncontrollable transition that is available when 
\family typewriter
tag==write8
\family default
.
 and that resets the 
\family typewriter
tag
\family default
 value to 
\family typewriter
idle
\family default
 upon completion.
 We encode the fact that every issued command eventually completes by adding
 a fair region 
\begin_inset Formula $\varphi=(tag\neq idle)$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\family typewriter
controllable
\family default
 state variable partitions the state space into controllable and uncontrollable
 states.
 Whenever the program is running inside a magic block, every uncontrollable
 transition can non-deterministically transfer control to the driver by
 assigning 
\family typewriter
controllable=true
\family default
.
 The driver then performs the next controllable action, e.g., issues the next
 command and returns control to the environment.
 An additional fair region encodes the requirement that whenever 
\family typewriter
magic==true
\family default
, the driver eventually gets control.
\end_layout

\begin_layout Standard
A separate controllable action is available to exit the magic block, in
 which case the driver does not regain control until another magic block
 is entered.
\end_layout

\begin_layout Subsection
Controllable predecessor
\end_layout

\begin_layout Standard
The 
\emph on
controllable predecessor
\emph default
 operator 
\begin_inset Formula $Cpre:\,2^{S}\rightarrow2^{S}$
\end_inset

 returns the set of states from which the system can force the game into
 a given region of the state space in one step by either performing a controllab
le transition or waiting for the environment to perform an uncontrollable
 transition out of the fair region:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre(V)=Cpre_{c}(V)\,\cup\, CpreFair_{u}(V)
\]

\end_inset

where
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{c}(V)=\{s\in S_{c}\mid\delta_{c}(s)\cap V\neq\emptyset\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CpreFair_{u}(V)=\bigcup_{\varphi\in\Phi}\nu X.\varphi\cap Cpre_{u}(X\cup V)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{u}(V)=\{s\in S_{u}\mid\delta_{u}(s)\subseteq V\}
\]

\end_inset


\end_layout

\begin_layout Subsection
Winning region
\end_layout

\begin_layout Standard
The set of winning states of the game can be computed as 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W=\mu X.\gamma\cup Cpre(X)
\]

\end_inset

the game is winning if 
\begin_inset Formula $I\subseteq W$
\end_inset

.
\end_layout

\begin_layout Section
Abstract games
\end_layout

\begin_layout Subsection
Definitions
\end_layout

\begin_layout Standard
An 
\emph on
abstraction of game
\emph default
 
\begin_inset Formula $G=\langle S,I,\Phi,\delta_{c},\delta_{u},\gamma\rangle$
\end_inset

 consists of a finite set of abstract states 
\begin_inset Formula $\Sigma$
\end_inset

 and a mapping 
\begin_inset Formula $\|.\|:\Sigma\rightarrow2^{S}$
\end_inset

.
 Abstraction defines partitioning of the concrete state space: 
\begin_inset Formula $\bigcup_{v\in\Sigma}\|v\|=S$
\end_inset

 and 
\begin_inset Formula $\forall v_{1},v\in\Sigma.v_{1}\neq v_{2}\implies\|v_{1}\|\cap\|v_{2}\|=\emptyset$
\end_inset

.
 
\end_layout

\begin_layout Standard
We define the following 
\emph on
concretisation
\emph default
 and 
\emph on
abstraction
\emph default
 operators.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\downarrow:2^{\Sigma}\rightarrow2^{S}$
\end_inset

, 
\begin_inset Formula $V\downarrow=\bigcup_{v\in V}\|v\|$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\uparrow^{m}:2^{S}\rightarrow2^{\Sigma}$
\end_inset

,
\begin_inset Formula $\sigma\uparrow^{m}=\{v\in\Sigma\mid\|v\|\cap\sigma\neq\emptyset\}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\uparrow^{M}:2^{S}\rightarrow2^{\Sigma}$
\end_inset

, 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\sigma\uparrow^{M}=\{v\in\Sigma\mid\|v\|\subseteq\sigma\}$
\end_inset


\end_layout

\begin_layout Standard
We assume that abstraction 
\begin_inset Formula $\Sigma$
\end_inset

 respects initial set 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
this requirement can be relaxed at the cost of slightly more complex refinement
 algorithm
\end_layout

\end_inset

, goal set, and fair sets of the game.
 We denote 
\begin_inset Formula $\hat{I}\doteq I\uparrow^{m}=I\uparrow^{M}$
\end_inset

, 
\begin_inset Formula $\hat{\gamma}\doteq\gamma\uparrow^{m}=\gamma\uparrow^{M}$
\end_inset

 and 
\begin_inset Formula $\hat{\Phi}=\{\varphi\uparrow^{m}\mid\varphi\in\Phi\}=\{\varphi\uparrow^{M}\mid\varphi\in\Phi\}$
\end_inset

.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Abstraction 
\begin_inset Formula $\Sigma$
\end_inset

 induces may and must abstract games:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
G^{m}=\langle\Sigma,I\uparrow^{m},\hat{\Phi},\delta_{c}^{m},\delta_{u}^{M},\hat{\gamma}\rangle
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
G^{M}=\langle\Sigma,I\uparrow^{M},\hat{\Phi},\delta_{c}^{M},\delta_{u}^{m},\hat{\gamma}\rangle
\]

\end_inset

where 
\begin_inset Formula 
\[
\delta^{m}=\{(v,v')\mid\exists s\in\|v\|,s'\in\|v'\|.(s,s')\in\delta\}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\delta^{M}=\{(v,v')\mid\forall s\in\|v\|.\exists s'\in\|v'\|.(s,s')\in\delta\}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Solving abstract games
\end_layout

\begin_layout Standard
Given abstraction 
\begin_inset Formula $\Sigma$
\end_inset

 of game 
\begin_inset Formula $G$
\end_inset

, we can compute may and must winning regions 
\begin_inset Formula $W^{m},W^{M}\subseteq\Sigma$
\end_inset

 of 
\begin_inset Formula $G$
\end_inset

 with respect to 
\begin_inset Formula $\Sigma$
\end_inset

, such that 
\begin_inset Formula $W^{M}\downarrow\subseteq W\subseteq W^{m}\downarrow$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W^{m(M)}=\mu X.\hat{\gamma}\cup Cpre^{m(M)}(X)
\]

\end_inset

where
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre^{m(M)}(V)=Cpre_{c}^{m(M)}(V)\,\cup\, CpreFair_{u}^{m(M)}(V)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{c}^{m(M)}(V)=Cpre_{c}(V\downarrow)\uparrow^{m(M)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{u}^{m(M)}(V)=Cpre_{c}(V\downarrow)\uparrow^{m(M)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CpreFair_{u}^{m(M)}(V)=\bigcup_{\varphi\in\hat{\Phi}}\nu X.\varphi\cap Cpre_{u}^{m(M)}(X\cup V)
\]

\end_inset

The 
\begin_inset Formula $Cpre_{c(u)}^{m(M)}$
\end_inset

 operators defined above require computing controllable predecessors over
 sets of concrete states, which is inefficient in practice.
 Therefore we compute over and under approximations:
\end_layout

\begin_layout Itemize
\begin_inset Formula $Cpre_{c(u)}^{m+}\supseteq Cpre_{c(u)}^{m}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Cpre_{c(u)}^{M-}\subseteq Cpre_{c(u)}^{M}$
\end_inset


\end_layout

\begin_layout Standard
and use these operators instead of 
\begin_inset Formula $Cpre_{c(u)}^{m(M)}$
\end_inset

 in the above algorithm.
\end_layout

\begin_layout Subsection
Abstraction refinement
\end_layout

\begin_layout Standard
Abstraction refinement is performed in case when abstraction 
\begin_inset Formula $\Sigma$
\end_inset

 and abstract controllable predecessor operators 
\begin_inset Formula $Cpre_{c(u)}^{m+(M-)}$
\end_inset

 are insufficient to solve the game, i.e., 
\begin_inset Formula $\hat{I}\subseteq W^{m}$
\end_inset

, but 
\begin_inset Formula $\hat{I}\nsubseteq W^{M}$
\end_inset

.
 
\end_layout

\begin_layout Standard
We choose an abstract state 
\begin_inset Formula $v\in(W^{m}\setminus W^{M})\cap Cpre^{m}(W^{M})$
\end_inset

 at the may-must boundary, such that one of the following two conditions
 holds: (1) 
\begin_inset Formula $v\in Cpre_{c}^{m+}(W^{M})\setminus Cpre_{c}^{M-}(W^{M})$
\end_inset

 or (2) 
\begin_inset Formula $v\in Cpre_{u}^{m+}(U)\setminus Cpre_{u}^{M-}(U)$
\end_inset

 where 
\begin_inset Formula $U$
\end_inset

 is the the set obtained at the last iteration of 
\begin_inset Formula $CpreFair_{u}^{m}(W^{M})$
\end_inset

 computation for some 
\begin_inset Formula $\varphi\in\hat{\Phi}$
\end_inset

.
 The existence of such 
\begin_inset Formula $v$
\end_inset

 follows from the definition of 
\begin_inset Formula $W^{m(M)}$
\end_inset

.
\end_layout

\begin_layout Standard
We first check whether 
\begin_inset Formula $v$
\end_inset

 can be either added to 
\begin_inset Formula $W^{M}$
\end_inset

 or eliminated from 
\begin_inset Formula $Cpre^{m}(W^{M})$
\end_inset

 without refining the abstraction, by computing more precise versions of
 
\begin_inset Formula $Cpre_{c(u)}^{m+(M-)}$
\end_inset

.
 In case (1) we check whether 
\begin_inset Formula $v\in Cpre_{c}^{M}(W^{M})$
\end_inset

 or 
\begin_inset Formula $v\notin Cpre_{c}^{m}(W^{M})$
\end_inset

.
 If the former condition holds then we refine 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Cpre_{c}^{M-}$
\end_inset

 so that 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $v\in Cpre_{c}^{M-}(W^{M})$
\end_inset

.
 If the latter condition holds then we refine 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Cpre_{c}^{m+}$
\end_inset

 so that 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $v\notin Cpre_{c}^{m+}(W^{M})$
\end_inset

.
 Likewise, in case (2) we check whether 
\begin_inset Formula $v\in Cpre_{u}^{M}(U)$
\end_inset

 or 
\begin_inset Formula $v\notin Cpre_{u}^{m}(U)$
\end_inset

 and refine 
\begin_inset Formula $Cpre_{u}^{m+}$
\end_inset

 or 
\begin_inset Formula $Cpre_{u}^{M-}$
\end_inset

 accordingly.
\end_layout

\begin_layout Standard
Otherwise we refine abstraction 
\begin_inset Formula $\Sigma$
\end_inset

 by splitting abstract state 
\begin_inset Formula $v$
\end_inset

 into two or more states 
\begin_inset Formula $\{v_{1}\ldots v_{k}\}$
\end_inset

 such that either 
\begin_inset Formula $v_{1}\in Cpre_{c}^{M}(W^{M})$
\end_inset

 (case (1)) or 
\begin_inset Formula $v\in Cpre_{u}^{M}(U)$
\end_inset

 (case (2)).
\end_layout

\begin_layout Section
Predicate abstraction
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "extra"
options "plain"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\end_body
\end_document
