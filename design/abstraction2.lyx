#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble



\newif\ifDraft\Draftfalse
%\Drafttrue


%\usepackage{scrartcl}

\usepackage{fancyhdr}\usepackage{times}\usepackage{amsthm}\usepackage{cite}


\usepackage[final,formats]{listings}

\newcommand{\src}[1]{\texttt{#1}}
\newcommand{\todo}[1]{\textit{\textbf{TODO: #1}}}

\newtheorem{proposition}{Proposition}


\title{Three-Valued Abstraction Refinement for Driver Synthesis}

\author{Leonid Ryzhyk}


\date{\today}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Three-Valued Abstraction Refinement for Driver Synthesis
\end_layout

\begin_layout Section
Concrete games
\end_layout

\begin_layout Subsection
Games
\end_layout

\begin_layout Standard
A 
\emph on
reachability game 
\emph default

\begin_inset Formula $G=\langle S,I,\Phi,\delta_{c},\delta_{u},\gamma\rangle$
\end_inset

 consists of:
\end_layout

\begin_layout Itemize
a state space 
\begin_inset Formula $S$
\end_inset

 partitioned into controllable states 
\begin_inset Formula $S_{c}$
\end_inset

 and uncontrollable states 
\begin_inset Formula $S_{u}$
\end_inset

, 
\begin_inset Formula $S_{c}\uplus S_{u}=S$
\end_inset

,
\end_layout

\begin_layout Itemize
a set of initial states 
\begin_inset Formula $I\subseteq S$
\end_inset

, 
\end_layout

\begin_layout Itemize
a set of fair regions 
\begin_inset Formula $\Phi\subseteq2^{S_{u}}\setminus\{\emptyset\}$
\end_inset

,
\end_layout

\begin_layout Itemize
a controllable transition relation 
\begin_inset Formula $\delta_{c}\subseteq S_{c}\times S$
\end_inset

,
\end_layout

\begin_layout Itemize
an uncontrollable transition relation 
\begin_inset Formula $\delta_{u}\subseteq S_{u}\times S$
\end_inset

,
\end_layout

\begin_layout Itemize
a set of goal states 
\begin_inset Formula $\gamma\subseteq S$
\end_inset

.
\end_layout

\begin_layout Standard
We assume that the environment can remain idle in every state, i.e 
\begin_inset Formula $\forall s\in S_{u}.\,(s,s)\in\delta_{u}$
\end_inset

.
\end_layout

\begin_layout Standard
The game objective is: 
\begin_inset Formula 
\[
\bigwedge_{\varphi\in\Phi}GF\varphi\rightarrow F\gamma
\]

\end_inset


\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
The above model is simpler than our previous model based on states and labels.
 First, it does not have labels (they become part of the state, as explained
 below).
 Second, it is a strictly turn-based game, where only one of the players
 can perform a move in each state.
 These simplifications will lead to simpler abstraction and synthesis algorithms.
 At the same time, this model allows capturing the nature of the interaction
 between the driver and the environment more precisely.
\end_layout

\begin_layout Standard
We briefly describe how a TSL2 specification can be encoded as a turn-based
 game.
 The state space of the game consists of all TSL variables and arguments
 of controllable and uncontrollable tasks.
 Every command issued by the driver to the device consists of two transitions.
 The first transition 
\emph on
issues
\emph default
 the command, i.e., assigns its arguments.
 The second transition 
\emph on
executes
\emph default
 the command.
 The two transitions can be separated by several transitions tiggered by
 other processes.
 Note that in a concrete game values of command arguments remain unchanged
 between the first and the second transitions.
 This is not necessarily true in an abstract game.
\end_layout

\begin_layout Paragraph
Example
\end_layout

\begin_layout Standard
Consider a controllable task 
\family typewriter
write8
\family default
 defined as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

task controllable void write8(addr, val)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   // body of the task
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This task can be invoked either manually by writing the following line in
 the driver template
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

write8(REG1_ADDR, 0);
\end_layout

\end_inset

or automatically, from synthesised code.
 In the former case the following uncontrollable transition is generated
 for the task invocation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

assume(controllable==false); // only available when the environment has
 control
\end_layout

\begin_layout Plain Layout

write8_addr = REG1_ADDR;
\end_layout

\begin_layout Plain Layout

write8_val = 0;
\end_layout

\begin_layout Plain Layout

tag = write8;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the latter case, the controllable transition can be encoded as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

assert((magic==true)&&(controllable==true)); // only available when running
 in a magic block and when the driver has control
\end_layout

\begin_layout Plain Layout

tag = write8;
\end_layout

\begin_layout Plain Layout

write8_addr = *;		// value to be chosen by the synthesis algorithm
\end_layout

\begin_layout Plain Layout

write8_val = *;		 // value to be chosen by the synthesis algorithm
\end_layout

\begin_layout Plain Layout

tag = write8;
\end_layout

\begin_layout Plain Layout

controllable=false;	 // return control to the environments
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Regardless of how the command was issued, the actual 
\family typewriter
write8
\family default
 operation is an uncontrollable transition that is available when 
\family typewriter
tag==write8
\family default
.
 and that resets the 
\family typewriter
tag
\family default
 value to 
\family typewriter
idle
\family default
 upon completion.
 We encode the fact that every issued command eventually completes by adding
 a fair region 
\begin_inset Formula $\varphi=(tag\neq idle)$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\family typewriter
controllable
\family default
 state variable partitions the state space into controllable and uncontrollable
 states.
 Whenever the program is running inside a magic block, every uncontrollable
 transition can non-deterministically transfer control to the driver by
 assigning 
\family typewriter
controllable=true
\family default
.
 The driver then performs the next controllable action, e.g., issues the next
 command and returns control to the environment.
 An additional fair region encodes the requirement that whenever 
\family typewriter
magic==true
\family default
, the driver eventually gets control.
\end_layout

\begin_layout Standard
A separate controllable action is available to exit the magic block, in
 which case the driver does not regain control until another magic block
 is entered.
\end_layout

\begin_layout Subsection
Controllable predecessor
\end_layout

\begin_layout Standard
The 
\emph on
controllable predecessor
\emph default
 operator 
\begin_inset Formula $Cpre:\,2^{S}\rightarrow2^{S}$
\end_inset

 returns the set of states from which the system can force the game into
 a given region of the state space in one step by either performing a controllab
le transition or waiting for the environment to perform an uncontrollable
 transition out of the fair region:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre(V)=Cpre_{c}(V)\,\cup\, CpreFair_{u}(V)
\]

\end_inset

where
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{c}(V)=\{s\in S_{c}\mid\delta_{c}(s)\cap V\neq\emptyset\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CpreFair_{u}(V)=\bigcup_{\varphi\in\Phi}\nu X.\varphi\cap Cpre_{u}(X\cup V)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{u}(V)=\{s\in S_{u}\mid\delta_{u}(s)\subseteq V\}
\]

\end_inset


\end_layout

\begin_layout Subsection
Winning region
\end_layout

\begin_layout Standard
The set of winning states of the game can be computed as 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W=\mu X.\gamma\cup Cpre(X)
\]

\end_inset

the game is winning if 
\begin_inset Formula $I\subseteq W$
\end_inset

.
\end_layout

\begin_layout Section
Abstract games
\end_layout

\begin_layout Subsection
Definitions
\end_layout

\begin_layout Standard
An 
\emph on
abstraction of game
\emph default
 
\begin_inset Formula $G=\langle S,I,\Phi,\delta_{c},\delta_{u},\gamma\rangle$
\end_inset

 consists of a finite set of abstract states 
\begin_inset Formula $\Sigma$
\end_inset

 and a 
\emph on
concretisation
\emph default
 operator
\begin_inset Formula $\downarrow:\Sigma\rightarrow2^{S}$
\end_inset

.
 Abstraction defines partitioning of the concrete state space: 
\begin_inset Formula $\bigcup_{v\in\Sigma}v\downarrow=S$
\end_inset

 and 
\begin_inset Formula $\forall v_{1},v\in\Sigma.v_{1}\neq v_{2}\implies v_{1}\downarrow\cap v_{2}\downarrow=\emptyset$
\end_inset

.
 
\end_layout

\begin_layout Standard
We extend the concretisation operator to sets of abstract states as follows:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\downarrow:2^{\Sigma}\rightarrow2^{S}$
\end_inset

, 
\begin_inset Formula $V\downarrow=\bigcup_{v\in V}v\downarrow$
\end_inset


\end_layout

\begin_layout Standard
We also define two 
\emph on
abstraction
\emph default
 operators:
\end_layout

\begin_layout Itemize
May-abstraction:
\begin_inset Formula $\uparrow^{m}:2^{S}\rightarrow2^{\Sigma}$
\end_inset

,
\begin_inset Formula $\sigma\uparrow^{m}=\{v\in\Sigma\mid v\downarrow\cap\sigma\neq\emptyset\}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Must-absteactionL
\begin_inset Formula $\uparrow^{M}:2^{S}\rightarrow2^{\Sigma}$
\end_inset

, 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\sigma\uparrow^{M}=\{v\in\Sigma\mid v\downarrow\subseteq\sigma\}$
\end_inset


\end_layout

\begin_layout Standard
We assume that abstraction 
\begin_inset Formula $\Sigma$
\end_inset

 respects initial set 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
this requirement can be relaxed at the cost of slightly more complex refinement
 algorithm
\end_layout

\end_inset

, goal set, and fair sets of the game.
 We denote 
\begin_inset Formula $\hat{I}\doteq I\uparrow^{m}=I\uparrow^{M}$
\end_inset

, 
\begin_inset Formula $\hat{\gamma}\doteq\gamma\uparrow^{m}=\gamma\uparrow^{M}$
\end_inset

 and 
\begin_inset Formula $\hat{\Phi}=\{\varphi\uparrow^{m}\mid\varphi\in\Phi\}=\{\varphi\uparrow^{M}\mid\varphi\in\Phi\}$
\end_inset

.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Abstraction 
\begin_inset Formula $\Sigma$
\end_inset

 induces may and must abstract games:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
G^{m}=\langle\Sigma,I\uparrow^{m},\hat{\Phi},\delta_{c}^{m},\delta_{u}^{M},\hat{\gamma}\rangle
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
G^{M}=\langle\Sigma,I\uparrow^{M},\hat{\Phi},\delta_{c}^{M},\delta_{u}^{m},\hat{\gamma}\rangle
\]

\end_inset

where 
\begin_inset Formula 
\[
\delta^{m}=\{(v,v')\mid\exists s\in\|v\|,s'\in\|v'\|.(s,s')\in\delta\}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\delta^{M}=\{(v,v')\mid\forall s\in\|v\|.\exists s'\in\|v'\|.(s,s')\in\delta\}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Solving abstract games
\end_layout

\begin_layout Standard
Given abstraction 
\begin_inset Formula $\Sigma$
\end_inset

 of game 
\begin_inset Formula $G$
\end_inset

, we can compute may and must winning regions 
\begin_inset Formula $W^{m},W^{M}\subseteq\Sigma$
\end_inset

 of 
\begin_inset Formula $G$
\end_inset

 with respect to 
\begin_inset Formula $\Sigma$
\end_inset

, such that 
\begin_inset Formula $W^{M}\downarrow\subseteq W\subseteq W^{m}\downarrow$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W^{m(M)}=\mu X.\hat{\gamma}\cup Cpre^{m(M)}(X)
\]

\end_inset

where
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre^{m(M)}(V)=Cpre_{c}^{m(M)}(V)\,\cup\, CpreFair_{u}^{m(M)}(V)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{c}^{m(M)}(V)=Cpre_{c}(V\downarrow)\uparrow^{m(M)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{u}^{m(M)}(V)=Cpre_{c}(V\downarrow)\uparrow^{m(M)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CpreFair_{u}^{m(M)}(V)=\bigcup_{\varphi\in\hat{\Phi}}\nu X.\varphi\cap Cpre_{u}^{m(M)}(X\cup V)
\]

\end_inset

The 
\begin_inset Formula $Cpre_{c(u)}^{m(M)}$
\end_inset

 operators defined above require computing controllable predecessors over
 sets of concrete states, which is inefficient in practice.
 Therefore we compute over and under approximations:
\end_layout

\begin_layout Itemize
\begin_inset Formula $Cpre_{c(u)}^{m+}\supseteq Cpre_{c(u)}^{m}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Cpre_{c(u)}^{M-}\subseteq Cpre_{c(u)}^{M}$
\end_inset


\end_layout

\begin_layout Standard
and use these operators instead of 
\begin_inset Formula $Cpre_{c(u)}^{m(M)}$
\end_inset

 in the above algorithm.
\end_layout

\begin_layout Subsection
Abstraction refinement
\end_layout

\begin_layout Standard
Abstraction refinement is performed in case when abstraction 
\begin_inset Formula $\Sigma$
\end_inset

 and abstract controllable predecessor operators 
\begin_inset Formula $Cpre_{c(u)}^{m+(M-)}$
\end_inset

 turn out to be too coarse to solve the concrete game, i.e., 
\begin_inset Formula $\hat{I}\subseteq W^{m}$
\end_inset

, but 
\begin_inset Formula $\hat{I}\nsubseteq W^{M}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: rewrite as an algorithm
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We choose an abstract state 
\begin_inset Formula $v\in(W^{m}\setminus W^{M})\cap Cpre^{m}(W^{M})$
\end_inset

 at the may-must boundary, such that one of the following two conditions
 holds: (1) 
\begin_inset Formula $v\in Cpre_{c}^{m+}(W^{M})\setminus Cpre_{c}^{M-}(W^{M})$
\end_inset

 or (2) 
\begin_inset Formula $v\in Cpre_{u}^{m+}(U)\setminus Cpre_{u}^{M-}(U)$
\end_inset

 where 
\begin_inset Formula $U$
\end_inset

 is the the set obtained at the last iteration of 
\begin_inset Formula $CpreFair_{u}^{m}(W^{M})$
\end_inset

 computation for some 
\begin_inset Formula $\varphi\in\hat{\Phi}$
\end_inset

.
 The existence of such 
\begin_inset Formula $v$
\end_inset

 follows from the definition of 
\begin_inset Formula $W^{m(M)}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
We first check whether 
\begin_inset Formula $v$
\end_inset

 can be either added to 
\begin_inset Formula $W^{M}$
\end_inset

 or eliminated from 
\begin_inset Formula $Cpre^{m}(W^{M})$
\end_inset

 without refining the abstraction, by computing more precise versions of
 
\begin_inset Formula $Cpre_{c(u)}^{m+(M-)}$
\end_inset

.
 In case (1) we check whether 
\begin_inset Formula $v\in Cpre_{c}^{M}(W^{M})$
\end_inset

 or 
\begin_inset Formula $v\notin Cpre_{c}^{m}(W^{M})$
\end_inset

.
 If the former condition holds then we refine 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Cpre_{c}^{M-}$
\end_inset

 so that 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $v\in Cpre_{c}^{M-}(W^{M})$
\end_inset

.
 If the latter condition holds then we refine 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Cpre_{c}^{m+}$
\end_inset

 so that 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $v\notin Cpre_{c}^{m+}(W^{M})$
\end_inset

.
 Likewise, in case (2) we check whether 
\begin_inset Formula $v\in Cpre_{u}^{M}(U)$
\end_inset

 or 
\begin_inset Formula $v\notin Cpre_{u}^{m}(U)$
\end_inset

 and refine 
\begin_inset Formula $Cpre_{u}^{m+}$
\end_inset

 or 
\begin_inset Formula $Cpre_{u}^{M-}$
\end_inset

 accordingly.
\end_layout

\begin_layout Plain Layout
Otherwise we refine abstraction 
\begin_inset Formula $\Sigma$
\end_inset

 by splitting abstract state 
\begin_inset Formula $v$
\end_inset

 into two or more states 
\begin_inset Formula $\{v_{1}\ldots v_{k}\}$
\end_inset

 such that either 
\begin_inset Formula $v_{1}\in Cpre_{c}^{M}(W^{M})$
\end_inset

 (case (1)) or 
\begin_inset Formula $v\in Cpre_{u}^{M}(U)$
\end_inset

 (case (2)).
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Abstraction-refinement"

\end_inset

Abstraction refinement
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Symbolic games
\end_layout

\begin_layout Subsection
Definitions
\end_layout

\begin_layout Standard
Symbolic games are defined over variables and expressions in some theory,
 e.g., integer linear arithmetic or bitvectors.
 
\end_layout

\begin_layout Itemize
Given a variable 
\begin_inset Formula $z$
\end_inset

 in the theory, we denote 
\begin_inset Formula $D(z)$
\end_inset

 the domain of 
\begin_inset Formula $z$
\end_inset

.
 
\end_layout

\begin_layout Standard
Given a vector of variables 
\begin_inset Formula $Z=\{z_{1},\ldots,z_{k}\}$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $D(Z)=\prod_{z\in Z}D(z)$
\end_inset

 is the cartesian product of individual variable domains
\end_layout

\begin_layout Itemize
\begin_inset Formula $Arith(Z)$
\end_inset

 is the set of arithmetic expressions over variables in 
\begin_inset Formula $Z$
\end_inset

 allowed by the theory.
 For example, in the theory of integer linear arithmetic 
\begin_inset Formula $Arith(Z)$
\end_inset

 consist of linear combinations of variables in 
\begin_inset Formula $Z$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Rel(Z)$
\end_inset

 is the set of 
\emph on
relational expressions
\emph default
, which consist of arithmetic expressions connected by relational operators
 of the theory, e.g.
\begin_inset Formula $=$
\end_inset

, 
\begin_inset Formula $\neq$
\end_inset

, 
\begin_inset Formula $<$
\end_inset

, 
\begin_inset Formula $\leq$
\end_inset

, 
\begin_inset Formula $>$
\end_inset

, 
\begin_inset Formula $\geq$
\end_inset

, 
\begin_inset Formula $\equiv$
\end_inset

, etc.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $Prop(X)$
\end_inset


\emph on
 
\emph default
is the set of 
\emph on
propositional expressions 
\emph default
constructed out of expressions in 
\begin_inset Formula $Rel(Z)$
\end_inset

 using boolean operators 
\begin_inset Formula $\land$
\end_inset

, 
\begin_inset Formula $\lor$
\end_inset

, and 
\begin_inset Formula $\lnot$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Z'=\{z_{1}',\ldots,z_{k}'\}$
\end_inset

 is the vector of primed versions of variables in 
\begin_inset Formula $Z$
\end_inset

.
 Primed variables are used to represent next-state
\emph on
 
\emph default
values of non-primed variables.
\end_layout

\begin_layout Standard
A 
\emph on
symbolic game 
\emph default

\begin_inset Formula $SG=\langle X,Y,init,fair,ctran,utran,goal\rangle$
\end_inset

 consist of 
\end_layout

\begin_layout Itemize
A vector of 
\emph on
state variables
\emph default
 
\begin_inset Formula $X$
\end_inset


\end_layout

\begin_layout Itemize
A vector of temporary variables 
\begin_inset Formula $Y$
\end_inset


\end_layout

\begin_layout Itemize
Initial state constraint 
\begin_inset Formula $init\in Prop(X)$
\end_inset


\end_layout

\begin_layout Itemize
Goal constraint 
\begin_inset Formula $goal\in Prop(X)$
\end_inset


\end_layout

\begin_layout Itemize
Fair regions 
\begin_inset Formula $fair\subseteq Prop(X)$
\end_inset


\end_layout

\begin_layout Itemize
Sets of controllable and uncontrollable 
\emph on
syntactic transitions
\emph default
 
\begin_inset Formula $ctran$
\end_inset

 and 
\begin_inset Formula $utran$
\end_inset

.
 A syntactic transition is a loop-free structured program constructed out
 of assignments and assume statements combined into sequential and or-blocks:
 
\begin_inset Formula 
\[
tran:\,\,(x:=e)\mid assume(p)\mid or(tran*)\mid seq(tran*)
\]

\end_inset

where
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $x\in X\cup T$
\end_inset

, 
\begin_inset Formula $e\in Arith(X\cup Y)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $p\in Prop(X\cup Y)$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Given a symbolic game 
\begin_inset Formula $SG=\langle X,Y,init,fair,ctran,utran,goal\rangle$
\end_inset

 we define the corresponding game 
\begin_inset Formula $G(SG)$
\end_inset

 as follows 
\begin_inset Formula 
\[
G(SG)=\langle D(X),\|init\|,\bigcup_{f\in fair}\|f\|,\bigcup_{\tau\in ctran}\|\tau\|,\bigcup_{\tau\in utran}\|\tau\|,\|goal\|\rangle
\]

\end_inset

where the 
\begin_inset Formula $\|.\|$
\end_inset

 operator maps propositional expressions and syntactic transitions into
 sets of states and sets of transitions according to their natural semantics.
\end_layout

\begin_layout Subsection
Predicate abstraction for symbolic games
\end_layout

\begin_layout Standard
Abstraction of a symbolic game 
\begin_inset Formula $SG=\langle X,Y,init,fair,ctran,utran,goal\rangle$
\end_inset

 is defined by a vector of predicates 
\begin_inset Formula $p=\{p_{1}\ldots p_{n}\}\subseteq Rel(X)$
\end_inset

.
 Each predicate 
\begin_inset Formula $p_{i}$
\end_inset

 is represented by a boolean variable 
\begin_inset Formula $P_{i}$
\end_inset

: 
\begin_inset Formula $P_{i}\Leftrightarrow p_{i}(X)$
\end_inset

.
 The concretisation function 
\begin_inset Formula $\downarrow$
\end_inset

 maps a vector of boolean values to a set of concrete state variable valuations:
 
\begin_inset Formula $\{b_{1}\ldots b_{n}\}\downarrow=\{x\in D(X)\mid\bigwedge_{i=1\ldots n}b_{i}=p_{i}(x)\}$
\end_inset

.
\end_layout

\begin_layout Standard
Given a syntactic transition 
\begin_inset Formula $\tau$
\end_inset

, we can compute next-state values of predicates in 
\begin_inset Formula $p$
\end_inset

 wrt 
\begin_inset Formula $\tau$
\end_inset

 as a function of 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

: 
\begin_inset Formula $P'=f(X,Y)$
\end_inset

.
 By replacing each atomic relational expression in 
\begin_inset Formula $f$
\end_inset

 with either existing predicate variable from 
\begin_inset Formula $P$
\end_inset

 or a fresh predicate variable, we obtain a function for computing next-state
 values of 
\begin_inset Formula $P$
\end_inset

: 
\begin_inset Formula $P'=\Delta_{t}(P,R,T)$
\end_inset

, where 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

 are vectors of fresh predicate variables over state and temporary variables:
 
\begin_inset Formula $R_{i}\Leftrightarrow r_{i}(X)$
\end_inset

, 
\begin_inset Formula $T_{j}\Leftrightarrow t_{j}(X,Y)$
\end_inset

.
\end_layout

\begin_layout Standard
The abstraction refinement algorithm maintains for each syntactic transition
 
\begin_inset Formula $t$
\end_inset

 an additional set of state predicates 
\begin_inset Formula $q=\{q_{1}\ldots q_{l}\}\subseteq Rel(X)$
\end_inset

 with corresponding variables 
\begin_inset Formula $Q$
\end_inset

.
 These predicates are used in computing controllable predecessor operators,
 as shown below, but they are not part of the abstract state space.
\end_layout

\begin_layout Standard
Abstract controllable predecessor operators are computed as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{u}^{m+}(V)=\bigcap_{t\in utran}Cpre_{u}^{m+}[t](V)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{u}^{M-}(V)=\bigcap_{t\in utran}Cpre_{u}^{M-}[t](V)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{c}^{m+}(V)=\bigcup_{t\in ctran}Cpre_{c}^{m+}[t](V)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{c}^{M-}(V)=\bigcup_{t\in ctran}Cpre_{c}^{M-}[t](V)
\]

\end_inset

where
\end_layout

\begin_layout Itemize
\begin_inset Formula $Cpre_{u}^{m+}[t](V)=\{P\mid\exists Q,R.(P,Q,R)\in consistent((p,q,r))\land(\forall T.((P,Q,R),T)\in consistent_{\forall}((p,q,r),t)\implies\Delta_{t}(P,R,T)\in V)\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Cpre_{u}^{M-}[t](V)=\{P\mid\forall R,T.(P,R,T)\in consistent((p,r,t))\implies\Delta_{t}(P,R,T)\in V\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Cpre_{c}^{m+}[t](V)=\{P\mid\exists R,T.(P,R,T)\in consistent((p,r,t))\land\Delta_{t}(P,R,T)\in V\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Cpre_{c}^{M-}[t](V)=\{P\mid\forall R.(P,Q,R)\in consistent((p,q,r))\implies(\exists T.((P,Q,R),T)\in consistent_{\forall}((p,q,r),t)\land\Delta_{t}(P,R,T)\in V)\}$
\end_inset


\end_layout

\begin_layout Itemize
For a vector of predicates 
\begin_inset Formula $u=\{u_{1}\ldots u_{m}\}\subseteq Rel(Z)$
\end_inset

, 
\begin_inset Formula $consistent(u)$
\end_inset

 is the set of boolean vectors that represent consistent values of 
\begin_inset Formula $u$
\end_inset

: 
\begin_inset Formula $consistent(u)=\{b\in\mathbb{B}^{m}\mid(\exists z.u(z)=b)\}$
\end_inset


\end_layout

\begin_layout Itemize
For two vectors of predicates 
\begin_inset Formula $u=\{u_{1}\ldots u_{m}\}\subseteq Rel(X)$
\end_inset

, 
\begin_inset Formula $w=\{w_{1}\ldots w_{k}\}\subseteq Rel(X\cup Y)$
\end_inset

, 
\begin_inset Formula $consistent_{\forall}(u,w)$
\end_inset

 consists of pairs of boolean vectors 
\begin_inset Formula $(b,c)$
\end_inset

 such that any concrete assignment of variables in 
\begin_inset Formula $X$
\end_inset

 under which 
\begin_inset Formula $u(x)=b$
\end_inset

 can be extended to an assignment of variables in 
\begin_inset Formula $Y$
\end_inset

 such that 
\begin_inset Formula $w(x,y)=c$
\end_inset

: 
\begin_inset Formula $consistent_{\forall}(u,w)=\{(b,c)\in\mathbb{B}^{m}\times\mathbb{B}^{k}\mid\forall x.(u(x)=b\implies\exists y.w(x,y)=c)\}$
\end_inset

.
\end_layout

\begin_layout Standard
Precise computation of 
\begin_inset Formula $consistent$
\end_inset

 and 
\begin_inset Formula $consistent_{\forall}$
\end_inset

 can be a bottleneck in computing 
\begin_inset Formula $Cpre_{c(u)}^{m+(M-)}[t]$
\end_inset

, especially when the number of predicates is large.
 To avoid this bottleneck, we overapproximate 
\begin_inset Formula $consistent$
\end_inset

 and underapproximate 
\begin_inset Formula $consistent_{\forall}$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $consistent^{+}(u)\supseteq consistent(u)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $consistent_{\forall}^{-}(u,w)\subseteq consistent_{\forall}(u,w)$
\end_inset


\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $consistent^{+}(u)$
\end_inset

 can be represented as a set of conflicting (i.e., inconsistent) assignments
 to subsets of predicates in 
\begin_inset Formula $u$
\end_inset

 that can be compactly stored e.g., in the BDD format.
 It can be incrementally extended with additional inconsistent assignments
 as they are discovered.
 Likewise, 
\begin_inset Formula $consistent_{\forall}^{-}(u,w)$
\end_inset

 can be represented as a set of satisfying assignments to predicates in
 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 and can be incrementally extended with additional assignments.
 We rely on such incremental computation of 
\begin_inset Formula $consistent^{+}$
\end_inset

 and 
\begin_inset Formula $consistent_{\forall}^{-}$
\end_inset

 in the abstraction refinement algorithm presented below.
\end_layout

\begin_layout Subsection
Abstraction refinement
\end_layout

\begin_layout Standard
Using controllable predecessor operators described in the previous section,
 we can symbolically compute may and must winning sets of the abstract game.
 In case the abstraction proves too coarse to solve the concrete game, i.e.,
 
\begin_inset Formula $\hat{I}\subseteq W^{m}$
\end_inset

, but 
\begin_inset Formula $\hat{I}\nsubseteq W^{M}$
\end_inset

, we refine the abstraction using Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Abstraction-refinement"

\end_inset

.
 Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Abstraction-refinement"

\end_inset

 relies on several primitive operations that must be concretised for symbolic
 games and predicate abstraction:
\end_layout

\begin_layout Itemize
Refining 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Cpre_{c}^{m+}$
\end_inset

:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 Given abstract state 
\begin_inset Formula $v$
\end_inset

 such that 
\begin_inset Formula $v\in Cpre_{c}^{m+}(V)$
\end_inset

 for some set 
\begin_inset Formula $V$
\end_inset

, check whether 
\begin_inset Formula $v\in Cpre_{c}^{m}(V)$
\end_inset

 and, if not, refine 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Cpre_{c}^{m+}$
\end_inset

 so that 
\begin_inset Formula $v\notin Cpre_{c}^{m+}(V)$
\end_inset

 after the refinement.
\end_layout

\begin_deeper
\begin_layout Enumerate
According to the definition of 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Cpre_{c}^{m+}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
, we can find a syntactic transition 
\begin_inset Formula $t$
\end_inset

 with abstract transition function 
\begin_inset Formula $\Delta_{t}(P,R,T)$
\end_inset

 such that there exist assignments to predicate variables 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

, such that 
\begin_inset Formula $(v,b,c)\in consistent^{+}((p,r,t))\land\Delta_{t}(v,b,c)\in V$
\end_inset

.
 We check whether 
\begin_inset Formula $(v,b,c)\in consistent((p,r,t))$
\end_inset

 or equivalently whether 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\exists x,y.p(x)=v\land r(x)=b\land t(x,y)=c$
\end_inset

.
 This check can be performed using an SMT solver.
 If the check succeeds then 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $(v,b,c)\in consistent((p,r,t))$
\end_inset

 and hence 
\begin_inset Formula $v\in Cpre_{c}^{m}(V)$
\end_inset

.
\end_layout

\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
In case the check fails, we refine 
\begin_inset Formula $consistent^{+}((p,r,t))$
\end_inset

.
 To this end we determine the minimal unsatisfiable subset of conjuncts
 of the above formula and add them to the set of conflicting assignments
 that encodes 
\begin_inset Formula $consistent^{+}((p,r,t))$
\end_inset

.
 We then recompute 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $Cpre_{c}^{m+}(V)$
\end_inset

 with the updated 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $consistent^{+}((p,r,t))$
\end_inset

.
 If 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $v\notin Cpre_{c}^{m+}(V)$
\end_inset

 then we have successfully refined 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Cpre_{c}^{m+}$
\end_inset

.
 Otherwise, go back to step 1.
\end_layout

\end_deeper
\begin_layout Itemize
Refining 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Cpre_{c}^{M-}$
\end_inset

:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 Given abstract state 
\begin_inset Formula $v\in Cpre_{c}^{m+}(V)\setminus Cpre_{c}^{M-}(V)$
\end_inset

 for some set 
\begin_inset Formula $V$
\end_inset

, check whether 
\begin_inset Formula $v\in Cpre_{c}^{M-}(V)$
\end_inset

 and, if yes, refine 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Cpre_{c}^{M-}$
\end_inset

 so that 
\begin_inset Formula $v\in Cpre_{c}^{M-}(V)$
\end_inset

 after the refinement.
\end_layout

\begin_layout Itemize
Refining 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Cpre_{u}^{m+}$
\end_inset

: Given abstract state 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $v\in Cpre_{u}^{m+}(V)\setminus Cpre_{u}^{M-}(V)$
\end_inset

 for some set 
\begin_inset Formula $V$
\end_inset

, check whether 
\begin_inset Formula $v\in Cpre_{u}^{m}(V)$
\end_inset

 and, if yes, refine 
\begin_inset Formula $Cpre_{u}^{m+}$
\end_inset

 so that 
\begin_inset Formula $v\notin Cpre_{u}^{m+}(V)$
\end_inset

 after the refinement
\end_layout

\begin_layout Itemize
Refining 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Cpre_{u}^{M-}$
\end_inset

: Given abstract state 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $v\in Cpre_{u}^{m+}(V)\setminus Cpre_{u}^{M-}(V)$
\end_inset

 for some set 
\begin_inset Formula $V$
\end_inset

, check whether 
\begin_inset Formula $v\in Cpre_{u}^{M}(V)$
\end_inset

 and, if yes, refine 
\begin_inset Formula $Cpre_{u}^{M-}$
\end_inset

 so that 
\begin_inset Formula $v\in Cpre_{u}^{M-}(V)$
\end_inset

 after the refinement
\end_layout

\begin_layout Itemize
Refining 
\begin_inset Formula $P$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
Case 1:
\begin_inset Formula $v\in Cpre_{c}^{m+}(V)\setminus Cpre_{c}^{M-}(V)$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Following Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Abstraction-refinement"

\end_inset

, we first check whether 
\begin_inset Formula $v\in Cpre_{c}^{m}(V)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $v\in Cpre_{c}^{M}(V)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Due to the choice of 
\begin_inset Formula $v$
\end_inset

 and according to the definition of 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "extra"
options "plain"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset


\end_layout

\end_body
\end_document
