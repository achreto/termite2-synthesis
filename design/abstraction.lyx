#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble



\newif\ifDraft\Draftfalse
%\Drafttrue


%\usepackage{scrartcl}

\usepackage{fancyhdr}\usepackage{times}\usepackage{amsthm}\usepackage{cite}


\usepackage[final,formats]{listings}

\newcommand{\src}[1]{\texttt{#1}}
\newcommand{\todo}[1]{\textit{\textbf{TODO: #1}}}

\newtheorem{proposition}{Proposition}


\title{Three-Valued Abstraction Refinement for Driver Synthesis}

\author{Leonid Ryzhyk}


\date{\today}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Three-Valued Abstraction Refinement for Driver Synthesis
\end_layout

\begin_layout Author
Leonid Ryzhyk
\end_layout

\begin_layout Date
10/08/12
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
We adapt the three-valued abstraction refinement algorithm of de Alfaro
 and Roy 
\begin_inset CommandInset citation
LatexCommand cite
key "deAlfaro_Roy_07"

\end_inset

 for use in the Termite driver synthesis tool.
 Specifically, we make the following improvements:
\end_layout

\begin_layout Itemize
The algorithm in 
\begin_inset CommandInset citation
LatexCommand cite
key "deAlfaro_Roy_07"

\end_inset

 assumes a turn-based game where the state space of the game can be partitioned
 into controllable and uncontrollable states.
 This is not the case in driver synthesis where controllable and uncontrollable
 moves can be simultaneously available in each state with controllable transitio
ns being potentially delayed by uncontrollable transitions.
 We adapt the three-valued abstraction refinement algorithm to these settings.
\end_layout

\begin_layout Itemize
The version of the abstraction refinement algorithm of 
\begin_inset CommandInset citation
LatexCommand cite
key "deAlfaro_Roy_07"

\end_inset

 for approximately computed may and must transition relations refines abstract
 states by partitioning them arbitrarily.
 While this algorithm is guaranteed to terminate for a class of problems,
 arbitrary partitioning can be inefficient in practice.
 In contrast our algorithm analyses the cause of imprecision and refines
 state and transition relations accordingly.
 It guarantees that evert refinement eliminates a source of imprecision
 and thus terminates faster in practice.
\end_layout

\begin_layout Itemize
We present a symbolic version of the three-valued abstraction refinement
 algorithm based on predicate abstraction.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
If we actually implement this, we can probably claim the first practical
 implementation of predicate-based abstraction refinement for games as well
 as the first implementation of predicate-based three-values abstraction
 refinement.
\end_layout

\end_inset

 The abstraction step is performed with the help of a modern theorem prover
 such as Z3, while the model checking step is performed purely symbolically,
 e.g., using BDD representation of abstract may- and must- transition relations.
\end_layout

\begin_layout Section
Definitions
\end_layout

\begin_layout Subsection
Games
\end_layout

\begin_layout Standard
A 
\emph on
game structure
\emph default
 
\begin_inset Formula $G=\langle S,L,I,\delta_{c},\delta_{u}\rangle$
\end_inset

 consists of:
\end_layout

\begin_layout Itemize
a state space 
\begin_inset Formula $S$
\end_inset

, 
\end_layout

\begin_layout Itemize
a set of 
\emph on
controllable
\emph default
 labels 
\begin_inset Formula $L$
\end_inset

,
\end_layout

\begin_layout Itemize
a subset of initial states 
\begin_inset Formula $I\subseteq S$
\end_inset

, 
\end_layout

\begin_layout Itemize
a controllable transition relation 
\begin_inset Formula $\delta_{c}:S\times L\rightarrow2^{S}$
\end_inset

,
\end_layout

\begin_layout Itemize
an uncontrollable transition relation 
\begin_inset Formula $\delta_{u}:S\rightarrow2^{S}$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\emph on
controllable predecessor
\emph default
 operator 
\begin_inset Formula $Cpre:\,2^{S}\rightarrow2^{S}$
\end_inset

 returns the set of states from which the system can force the game into
 a given region of the state space in one step:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre(X)=Cpre_{c}(X)\,\cup\, Cpre_{u}(X)
\]

\end_inset

where
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{c}(X)=\{s\in S\mid\exists l\in L.\forall s'\in\delta_{u}^{*}(s).\,\delta_{c}(s',l)\cap X\neq\emptyset\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{u}(X)=\{s\in S\mid\delta_{u}(s)\neq\emptyset\land\delta_{u}(s)\subseteq X\}
\]

\end_inset


\end_layout

\begin_layout Subsection
Abstractions of games
\begin_inset CommandInset label
LatexCommand label
name "sub:Abstractions-of-games"

\end_inset


\end_layout

\begin_layout Standard
An abstraction 
\begin_inset Formula $\Gamma=\langle\Sigma,\Lambda\rangle$
\end_inset

 of a game 
\begin_inset Formula $G=\langle S,L,I,\delta_{c},\delta_{u}\rangle$
\end_inset

consists of 
\end_layout

\begin_layout Itemize
a finite set of abstract states 
\begin_inset Formula $\Sigma$
\end_inset

 and a mapping 
\begin_inset Formula $\|.\|_{\Sigma}:\Sigma\rightarrow2^{S}$
\end_inset

 from abstract states to sets of concrete states, such that
\begin_inset Formula $\bigcup_{v_{i}\in\Sigma}\|v_{i}\|_{\Sigma}=S$
\end_inset

, and 
\begin_inset Formula $\forall v_{i},v_{j}\in\Sigma.\,(\|v_{i}\|_{\Sigma}\cap\|v_{j}\|_{\Sigma}=\emptyset)\lor(\|v_{i}\|_{\Sigma}=\|v_{j}\|_{\Sigma})$
\end_inset

.
\end_layout

\begin_layout Itemize
a finite set of extended abstract states (state+label) 
\begin_inset Formula $\Lambda$
\end_inset

 and a mapping 
\begin_inset Formula $\|.\|_{\Lambda}:\Lambda\rightarrow2^{S\times L}$
\end_inset

, such that 
\begin_inset Formula $\bigcup_{a_{i}\in\Lambda}\|a_{i}\|_{\Lambda}=S\times L$
\end_inset

 and 
\begin_inset Formula $\forall a_{i},a_{j}\in\Sigma.\,(\|a_{i}\|_{\Lambda}\cap\|a_{j}\|_{\Lambda}=\emptyset)\lor(\|a_{i}\|_{\Lambda}=\|a_{j}\|_{\Lambda})$
\end_inset

.
 Extended abstract states must agree with abstract states: 
\begin_inset Formula $\forall a\in\Lambda.\exists v\in\Sigma.\forall(s,l)\in\|a\|_{\Lambda}.\, s\in\|v\|_{\Sigma}$
\end_inset

.
 We write 
\begin_inset Formula $proj(a)=v$
\end_inset

 for a projection of an extended abstract state on the abstract state space.
\end_layout

\begin_layout Standard
We define may and must versions of abstract transition relations:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Delta_{c}^{m},\Delta_{c}^{M}:\Lambda\rightarrow2^{\Sigma}$
\end_inset

 are the may and must versions of the controllable transition relation
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Delta_{c}^{m}(a)=\{v'\in\Sigma\mid\exists(s,l)\in\|a\|.\,\delta_{c}(s,l)\cap\|v'\|\neq\emptyset\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Delta_{c}^{M}(a)=\{v'\in\Sigma\mid\forall(s,l)\in\|a\|.\,\delta_{c}(s,l)\cap\|v'\|\neq\emptyset\}
\]

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Delta_{u}^{m},\Delta_{u}^{M}:\Sigma\rightarrow2^{\Sigma}$
\end_inset

 are the may and must versions of the uncontrollable transition relation
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Delta_{u}^{m}(v)=\{v'\in\Sigma\mid\exists s\in\|v\|.\,\delta_{u}(s)\cap\|v'\|\neq\emptyset\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Delta_{u}^{M}(v)=\{v'\in\Sigma\mid\forall s\in\|v\|.\,\delta_{u}(s)\cap\|v'\|\neq\emptyset\}
\]

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\gamma_{u}^{m},\gamma_{u}^{M}:\Lambda\rightarrow2^{\Lambda}$
\end_inset

 are the may and must versions of the extended uncontrollable transition
 relation
\begin_inset Formula 
\[
\gamma_{u}^{m}(a)=\{a'\in\Lambda\mid\exists(s,l)\in\|a\|.\exists s'\in\delta_{u}(s).\,(s',l)\in\|a'\|\}
\]

\end_inset


\begin_inset Formula 
\[
\gamma_{u}^{M}(a)=\{a'\in\Lambda\mid\forall(s,l)\in\|a\|.\exists s'\in\delta_{u}(s).\,(s',l)\in\|a'\|\}
\]

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Avl:\Sigma\rightarrow2^{2^{\Lambda}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Avl(v)=\{\alpha\subseteq\Lambda\mid\forall s\in\|v\|.\exists l\in L,a\in\alpha.\,(s,l)\in\|a\|\}
\]

\end_inset


\end_layout

\begin_layout Standard
When using predicate abstraction, we further over and under-approximate
 these relations in order to be able to compute them efficiently:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Delta_{c}^{m+}\supseteq\Delta_{c}^{m}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Delta_{c}^{M-}\subseteq\Delta_{c}^{M}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Delta_{u}^{m+}\supseteq\Delta_{u}^{m}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Delta_{u}^{M-}\subseteq\Delta_{u}^{M}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\gamma_{u}^{m+}\supseteq\gamma_{u}^{m}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\gamma_{u}^{M-}\subseteq\gamma_{u}^{M}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Avl^{-}\subseteq Avl$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Avl^{+}\supseteq Avl^{-}$
\end_inset

 We do not require that 
\begin_inset Formula $Avl^{+}\supseteq Avl$
\end_inset

, as there may be no efficient way to compute such 
\begin_inset Formula $Avl^{+}$
\end_inset

.
 Instead, we require that 
\begin_inset Formula $\forall\alpha\in Avl.\exists\beta\in Avl^{+},\alpha\subseteq\beta$
\end_inset

.
\end_layout

\begin_layout Standard
Using these abstract transition relations, we can define an over-approximation
 
\begin_inset Formula $Cpre^{m}:\,2^{\Sigma}\mapsto2^{\Sigma}$
\end_inset

 and an under-approximation 
\begin_inset Formula $Cpre^{M}:\,2^{\Sigma}\mapsto2^{\Sigma}$
\end_inset

 of the controllable predecessor operator:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre^{m}(U)=Cpre_{c}^{m}(U)\,\cup\, Cpre_{u}^{m}(U)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre^{M}(U)=Cpre_{c}^{M}(U)\,\cup\, Cpre_{u}^{M}(U)
\]

\end_inset

where
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
Cpre_{c}^{m}(U)=\{v\in\Sigma\mid\exists\alpha\in Avl^{+}(v).\exists a\in\alpha.\,\forall a'\in(\gamma_{u}^{M-})^{*}(a).\Delta_{c}^{m+}(a')\cap U\neq\emptyset\}\label{eq:cprecm}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
Cpre_{c}^{M}(U)=\{v\in\Sigma\mid\exists\alpha\in Avl^{-}(v).\forall a\in\alpha.\,\forall a'\in(\gamma_{u}^{m+})^{*}(a).\Delta_{c}^{M-}(a')\cap U\neq\emptyset\}\label{eq:cprecM}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
Cpre_{u}^{m}(U)=\{v\in\Sigma\mid\Delta_{u}^{M-}(v)\neq\emptyset\land\Delta_{u}^{M-}(v)\subseteq U\}\,\cup\,\{v\in\Sigma\mid\Delta_{u}^{M-}(v)=\emptyset\land\Delta_{u}^{m+}(v)\cap U\neq\emptyset\}\label{eq:cpreum}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
Cpre_{u}^{M}(U)=\{v\in\Sigma\mid\Delta_{u}^{m+}(v)\neq\emptyset\land\Delta_{u}^{m+}(v)\subseteq U\}\label{eq:cpreuM}
\end{equation}

\end_inset


\end_layout

\begin_layout Section
Abstraction refinement
\begin_inset CommandInset label
LatexCommand label
name "sec:Abstraction-refinement"

\end_inset


\end_layout

\begin_layout Standard
In case there exists a may-winning strategy, but no must-winning strategy,
 we refine an abstract state on the may-must boundary.
 Such a state must satisfy one of two conditions:
\end_layout

\begin_layout Itemize
Case 1: 
\begin_inset Formula $v\in(W^{m}\setminus W^{M})\,\cap\, Cpre_{c}^{m}(W^{M})$
\end_inset


\end_layout

\begin_layout Itemize
Case 2: 
\begin_inset Formula $v\in(W^{m}\setminus W^{M})\,\cap\, Cpre_{u}^{m}(W^{M})$
\end_inset


\end_layout

\begin_layout Standard
Consider case 1.
 We have 
\begin_inset Formula $v\in Cpre_{c}^{m}(W^{M})$
\end_inset

 and 
\begin_inset Formula $v\notin Cpre_{c}^{M}(W^{M})$
\end_inset

.
 According to 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cprecm"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cprecM"

\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\exists\alpha\in Avl^{+}(v).\exists a\in\alpha.\,\forall a'\in(\gamma_{u}^{M-})^{*}(a).\Delta_{c}^{m+}(a')\cap W^{M}\neq\emptyset$
\end_inset

, but 
\begin_inset Formula $\forall\alpha\in Avl^{-}(v).\exists a\in\alpha.\exists a'\in(\gamma_{u}^{m+})^{*}(a).\Delta_{c}^{M-}(a')\cap W^{M}=\emptyset$
\end_inset

.
 We choose a 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
minimal
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $\alpha$
\end_inset

 that satisfies the first equation, i.e.
 
\begin_inset Formula $\nexists\alpha'\in Avl^{+}(v).\alpha'\subset\alpha$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Case 1.1: 
\begin_inset Formula $\alpha\notin Avl^{-}(v)$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
Case 1.1.1: 
\begin_inset Formula $\alpha\in Avl(v)$
\end_inset

.
 We refine 
\begin_inset Formula $Avl^{-}$
\end_inset

: 
\begin_inset Formula $Avl^{-}(v)\colon=Avl^{-}(v)\cup\{\alpha\}$
\end_inset

.
\end_layout

\begin_layout Itemize
Case 1.1.2:
\begin_inset Formula $\alpha\notin Avl(v)$
\end_inset

.
 We refine 
\begin_inset Formula $Avl^{+}$
\end_inset

: 
\begin_inset Formula $Avl^{-}(v):=Avl^{-}(v)\setminus\{\alpha\}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Case 1.2: 
\begin_inset Formula $\alpha\in Avl^{-}(v)$
\end_inset

.
 Partition 
\begin_inset Formula $\alpha$
\end_inset

 into may-winning states 
\begin_inset Formula $\hat{\alpha}=\{a\in\alpha|\forall a'\in(\gamma_{u}^{M-})^{*}(a).\Delta_{c}^{m+}(a')\cap W^{M}\neq\emptyset\}$
\end_inset

 and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
may-losing states 
\begin_inset Formula $\check{\alpha}=\alpha\setminus\hat{\alpha}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Case 1.2.1: 
\begin_inset Formula $\check{\alpha}\neq\emptyset$
\end_inset

.
 Refine 
\begin_inset Formula $v$
\end_inset

 by partitioning it into 2 or more states 
\begin_inset Formula $\{v_{1},\ldots,v_{k}\}$
\end_inset

 such that 
\begin_inset Formula $\exists\alpha'\in Avl(v_{1}).\,\alpha'\subseteq\hat{\alpha}$
\end_inset


\end_layout

\begin_layout Itemize
Case 1.2.2: 
\begin_inset Formula $\check{\alpha}=\emptyset$
\end_inset

, i.e., all extended abstract states in 
\begin_inset Formula $\alpha$
\end_inset

 are may-winning; however 
\begin_inset Formula $\alpha$
\end_inset

 is not must-winning, i.e., 
\begin_inset Formula $\exists a\in\alpha.\exists a'\in(\gamma_{u}^{m+})^{*}(a).\Delta_{c}^{M-}(a')\cap W^{M}=\emptyset$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Case 1.2.2.1: 
\begin_inset Formula $a'\notin(\gamma_{u}^{M-})^{*}(a)$
\end_inset

.
 In this case there exists extended abstract state 
\begin_inset Formula $b\in(\gamma_{u}^{M-})^{*}(a)$
\end_inset

 such that 
\begin_inset Formula $a'\in\gamma_{u}^{m+}(b)$
\end_inset

 (Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:maymust"

\end_inset

).
 We partition 
\begin_inset Formula $b$
\end_inset

 into 
\begin_inset Formula $\hat{b}$
\end_inset

 and 
\begin_inset Formula $\check{b}$
\end_inset

 such that 
\begin_inset Formula $\|\hat{b}\|=\{(s,l)\in\|b\|\mid\exists s'\in\delta_{u}(s).\,(s',l)\in\|a'\|\}$
\end_inset

 and 
\begin_inset Formula $\|\check{b}\|=\|b\|\setminus\|\hat{b}\|$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Case 1.2.2.1.1: 
\begin_inset Formula $\hat{b}=\emptyset$
\end_inset

.
 We eliminate the spurious transition 
\begin_inset Formula $b\rightarrow a'$
\end_inset

 from 
\begin_inset Formula $\gamma_{u}^{m+}$
\end_inset


\end_layout

\begin_layout Itemize
Case 1.2.2.1.2: 
\begin_inset Formula $\check{b}=\emptyset$
\end_inset

.
 We add the missing transition 
\begin_inset Formula $b\rightarrow a'$
\end_inset

 to 
\begin_inset Formula $\gamma_{u}^{M-}$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Case 1.2.2.1.3: Otherwise, we replace extended abstract state 
\begin_inset Formula $b$
\end_inset

 with the pair of abstract states 
\begin_inset Formula $\hat{b}$
\end_inset

 and 
\begin_inset Formula $\check{b}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Case 1.2.2.2: 
\begin_inset Formula $a'\in(\gamma_{u}^{M-})^{*}(a)$
\end_inset

.
 We pick a state 
\begin_inset Formula $w\in\Delta_{c}^{m+}(a')\cap W^{M}$
\end_inset

 and partition 
\begin_inset Formula $a'$
\end_inset

 into 
\begin_inset Formula $\hat{a}'=\{(s,l)\in\|a'\|\mid\delta_{c}(s,l)\cap\|w\|\neq\emptyset\}$
\end_inset

 and 
\begin_inset Formula $\check{a}'=a'\setminus\hat{a}'$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Case 1.2.2.2.1: If 
\begin_inset Formula $\hat{a}'=\emptyset$
\end_inset

, then we eliminate the spurious controllable transition 
\begin_inset Formula $a'\rightarrow w$
\end_inset

 from
\begin_inset Formula $\Delta_{c}^{m+}$
\end_inset

.
\end_layout

\begin_layout Itemize
Case 1.2.2.2.2: If 
\begin_inset Formula $\check{a}'=\emptyset$
\end_inset

, then we add transition 
\begin_inset Formula $a'\rightarrow w$
\end_inset

 to 
\begin_inset Formula $\Delta_{c}^{M-}$
\end_inset

.
\end_layout

\begin_layout Itemize
Case 1.2.2.2.3: Otherwise, we replace extended abstract state 
\begin_inset Formula $a'$
\end_inset

 with the pair of extended abstract states 
\begin_inset Formula $\hat{a}'$
\end_inset

 and 
\begin_inset Formula $\check{a}'$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename maymust.eps

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:maymust"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider case 2.
 We have 
\begin_inset Formula $v\in Cpre_{u}^{m}(W^{M})$
\end_inset

 and 
\begin_inset Formula $v\notin Cpre_{u}^{M}(W^{M})$
\end_inset

.
 According to the negation of 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cpreuM"

\end_inset

, there exists 
\begin_inset Formula $z\in\Delta_{u}^{m+}(v)$
\end_inset

, 
\begin_inset Formula $z\notin W^{M}$
\end_inset

.
 We partition 
\begin_inset Formula $v$
\end_inset

 into 
\begin_inset Formula $\hat{v}$
\end_inset

 and 
\begin_inset Formula $\check{v}$
\end_inset

, such that 
\begin_inset Formula $\|\hat{v}\|=\{s\in\|v\|\mid\exists s'\in\delta_{u}(s).\, s'\in\|z\|\}$
\end_inset

 and 
\begin_inset Formula $\|\check{v}\|=\|v\|\setminus\|\hat{v}\|$
\end_inset

.
\end_layout

\begin_layout Itemize
Case 2.1: 
\begin_inset Formula $\|\hat{v}\|=\emptyset$
\end_inset

.
 We eliminate spurious transition 
\begin_inset Formula $v\rightarrow z$
\end_inset

 from 
\begin_inset Formula $\Delta_{u}^{m+}$
\end_inset


\end_layout

\begin_layout Itemize
Case 2.2: 
\begin_inset Formula $\|\check{v}\|=\emptyset$
\end_inset

.
 We add transition 
\begin_inset Formula $v\rightarrow z$
\end_inset

 to 
\begin_inset Formula $\Delta_{u}^{M-}$
\end_inset


\end_layout

\begin_layout Itemize
Case 2.3: Otherwise, we replace abstract state 
\begin_inset Formula $v$
\end_inset

 with the pair of states 
\begin_inset Formula $\hat{v}$
\end_inset

 and 
\begin_inset Formula $\check{v}$
\end_inset

.
\end_layout

\begin_layout Section
Symbolic games
\end_layout

\begin_layout Standard
Symbolic games are defined over variables and expressions in some theory,
 e.g., integer linear arithmetic or bitvectors.
 
\end_layout

\begin_layout Itemize
Given a variable 
\begin_inset Formula $z$
\end_inset

 in the theory, we denote 
\begin_inset Formula $D(z)$
\end_inset

 the domain of 
\begin_inset Formula $z$
\end_inset

.
 
\end_layout

\begin_layout Standard
Given a set of variables 
\begin_inset Formula $Z=\{z_{1},\ldots,z_{k}\}$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $D(Z)=\prod_{z\in Z}D(z)$
\end_inset

 is the cartesian product of individual variable domains
\end_layout

\begin_layout Itemize
\begin_inset Formula $Arith(Z)$
\end_inset

 is the set of arithmetic expressions over variables in 
\begin_inset Formula $Z$
\end_inset

 allowed by the theory.
 For example, in the theory of integer linear arithmetic 
\begin_inset Formula $Arith(Z)$
\end_inset

 consist of linear combinations of variables in 
\begin_inset Formula $Z$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Rel(Z)$
\end_inset

 is the set of 
\emph on
relational expressions
\emph default
, which consist of arithmetic expressions connected by relational operators
 of the theory, e.g.
\begin_inset Formula $=$
\end_inset

, 
\begin_inset Formula $\neq$
\end_inset

, 
\begin_inset Formula $<$
\end_inset

, 
\begin_inset Formula $\leq$
\end_inset

, 
\begin_inset Formula $>$
\end_inset

, 
\begin_inset Formula $\geq$
\end_inset

, 
\begin_inset Formula $\equiv$
\end_inset

, etc.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $Prop(X)$
\end_inset


\emph on
 
\emph default
is the set of 
\emph on
propositional expressions 
\emph default
constructed out of expressions in 
\begin_inset Formula $Rel(Z)$
\end_inset

 using boolean operators 
\begin_inset Formula $\land$
\end_inset

, 
\begin_inset Formula $\lor$
\end_inset

, and 
\begin_inset Formula $\lnot$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Z'=\{z_{1}',\ldots,z_{k}'\}$
\end_inset

 is the set of primed versions of variables in 
\begin_inset Formula $Z$
\end_inset

.
 Primed variables are used to represent next-state
\emph on
 
\emph default
values of non-primed variables.
\end_layout

\begin_layout Standard
A 
\emph on
symbolic game structure
\emph default
 
\begin_inset Formula $SG=\langle X,Y,T,init,ctran,utran\rangle$
\end_inset

 consist of 
\end_layout

\begin_layout Itemize
Finite set of 
\emph on
state variables
\emph default
 
\begin_inset Formula $X$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Finite set of 
\emph on
controllable label variables
\emph default
 
\begin_inset Formula $Y$
\end_inset

.
\end_layout

\begin_layout Itemize
Finite set of 
\emph on
temporary variable
\emph default
 
\begin_inset Formula $T$
\end_inset


\end_layout

\begin_layout Itemize
Initial state constraint 
\begin_inset Formula $init\in Prop(X)$
\end_inset

.
\end_layout

\begin_layout Itemize
A set of 
\emph on
controllable syntactic transitions
\emph default
 
\begin_inset Formula $ctran\subset Tran(X,Y,T)$
\end_inset

 and a set of 
\emph on
uncontrollable syntactic transitions
\emph default
 
\begin_inset Formula $utran\subset Tran(X,\emptyset,T)$
\end_inset

.
 
\begin_inset Formula $Tran(X,Y,T)$
\end_inset

 is the set of syntactic transitions over state variables 
\begin_inset Formula $X$
\end_inset

, controllable lable variables 
\begin_inset Formula $Y$
\end_inset

, and temporary variables 
\begin_inset Formula $T$
\end_inset

.
 A syntactic transition is a loop-free structured program constructed out
 of assignments and assume statements combined into sequential and or-blocks:
 
\begin_inset Formula 
\[
tran:\,\,(x:=e)\mid assume(p)\mid or(tran*)\mid seq(tran*)
\]

\end_inset

where
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $x\in X'\cup T$
\end_inset

, 
\begin_inset Formula $e\in Arith(X\cup Y\cup T\cup X')$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $p\in Prop(X\cup Y\cup T\cup X')$
\end_inset


\end_layout

\begin_layout Itemize
variable 
\begin_inset Formula $x'\in X'\cup T$
\end_inset

 can occur at most once in the left-hand side of an assignment statement
 in the transition
\end_layout

\begin_layout Itemize
a variable 
\begin_inset Formula $x'\in X'\cup T$
\end_inset

 can be assigned at most once in every path through the transition.
 If 
\begin_inset Formula $x$
\end_inset

 is assigned in one path, it must be assigned in all paths.
\end_layout

\begin_layout Itemize
if a variable 
\begin_inset Formula $x'\in X'\cup T$
\end_inset

 occurs in the left-hand side of an assignment, it can only be used in the
 right-hand side of an assignment or in an assume-statement following the
 location where it is assigned.
\end_layout

\begin_layout Standard
A syntactic transition may only assign a subset of state variables.
 The remaining variables are implicitly assigned to their old values.
 The transition can be extended to explicitly update all state variables
 by appending a statement of the form 
\begin_inset Formula $x':=x$
\end_inset

 for each state variable 
\begin_inset Formula $x$
\end_inset

 not modified by the transition.
 This transformation is performed by the function 
\begin_inset Formula $Ext(X,t)$
\end_inset

, where 
\begin_inset Formula $X$
\end_inset

 is the set of state variables that must be assigned by transition 
\begin_inset Formula $t$
\end_inset

.
 In the sequel, we assume that syntactic transitions are in the extended
 form.
\end_layout

\begin_layout Standard
A syntactic transition can be converted to an equivalent propositional formula
 using function 
\begin_inset Formula $\delta:Tran(X,Y,T)\rightarrow Prop(X\cup Y\cup T\cup X')$
\end_inset

 defined as follows:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta((x:=e))=(x=e)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta(assume(p))=p$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta(seq(s_{1},\ldots,s_{k}))=\bigwedge_{1\leq i\leq k}\delta(s_{i})$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta(or(s_{1},\ldots,s_{k}))=\bigvee_{1\leq i\leq k}\delta(s_{i})$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Finite set of 
\emph on
temporary variables
\emph default
 
\begin_inset Formula $T$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a symbolic game structure 
\begin_inset Formula $SG=\langle X,Y,T,init,ctran,utran\rangle$
\end_inset

 we define the corresponding game structure 
\begin_inset Formula $G(SG)$
\end_inset

 as follows 
\begin_inset Formula 
\[
G(SG)=\langle D(X),D(Y),\|init\|_{p},\bigcup_{t\in ctran}\|t\|_{c},\bigcup_{t\in utran}\|t\|_{u}\rangle
\]

\end_inset

where
\end_layout

\begin_layout Itemize
\begin_inset Formula $\|.\|_{p}:Prop(Z)\rightarrow2^{D(Z)}$
\end_inset

.
 
\begin_inset Formula $\|exp\|=\{v\in D(Z)\mid v\models exp\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\|.\|_{c}:Tran(X,Y,T)\rightarrow(D(X)\times D(Y)\rightarrow2^{D(X)})$
\end_inset

.
 
\begin_inset Formula $\|tran\|_{c}(s,l)=\{s'\in D(X')\mid\exists t\in D(T).\,(s,l,t,s')\models\delta(tran)\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\|.\|_{u}:Tran(X,\emptyset,T)\rightarrow(D(X)\rightarrow2^{D(X)})$
\end_inset

.
 
\begin_inset Formula $\|t\|_{u}(s)=\{s'\in D(X')\mid\exists t\in D(T).\,(s,t,s')\models\delta(t)\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Controllable syntactic transitions must be deterministic with respect to
 state and label variables: 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Abstraction
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $Pred(Z)\subseteq Rel(Z)$
\end_inset

 be the set of boolean predicates over variables in 
\begin_inset Formula $Z$
\end_inset

.
 Given a set 
\begin_inset Formula $Q\subseteq Pred(Z)$
\end_inset

 of predicates over variables 
\begin_inset Formula $Z$
\end_inset

, 
\begin_inset Formula $Q'\subseteq Pred(Z')$
\end_inset

 is the set of the same predicates over primed versions of variables in
 
\begin_inset Formula $Z$
\end_inset

.
\end_layout

\begin_layout Standard
Given a symbolic game structure 
\begin_inset Formula $SG=\langle X,Y,T,init,ctran,utran\rangle$
\end_inset

, we define abstraction 
\begin_inset Formula $\Gamma(SG,P_{S},P_{L})$
\end_inset

 of 
\begin_inset Formula $G(SG)$
\end_inset

 with respect to two finite sets of predicates:
\end_layout

\begin_layout Itemize

\emph on
state predicates
\emph default
 
\begin_inset Formula $P_{S}=\{\sigma_{1},\ldots,\sigma_{k}\}$
\end_inset

, 
\begin_inset Formula $\sigma_{i}\in Pred(X)$
\end_inset


\end_layout

\begin_layout Itemize

\emph on
label predicates
\emph default
 
\begin_inset Formula $P_{L}=\{\lambda_{1},\ldots,\lambda_{m}\}$
\end_inset

, 
\begin_inset Formula $\lambda_{i}\in Pred(X\cup Y)$
\end_inset


\end_layout

\begin_layout Standard
as follows: 
\begin_inset Formula $\Gamma(SG,\Pi,\Theta)=\langle\mathbb{B}^{k},\mathbb{B}^{k+m}\rangle$
\end_inset

, where 
\begin_inset Formula $\mathbb{B}^{k}$
\end_inset

 is the set of abstract states, and 
\begin_inset Formula $\mathbb{B}^{k+m}$
\end_inset

 is the set of extended abstract states, with
\end_layout

\begin_layout Itemize
\begin_inset Formula $\|(b_{1},\ldots,b_{k})\|_{\Sigma}=\{s\in D(X)\mid\bigwedge_{i\in1\ldots k}\sigma_{i}(s)=b_{i}\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\|(b_{1},\ldots,b_{k+m})\|_{\Lambda}=\{a\in D(X\cup Y_{c})\mid(\bigwedge_{i\in1\ldots k}\sigma_{i}(a)=b_{i})\land(\bigwedge_{i\in1\ldots m}\lambda_{i}(a)=b_{k+1})\}$
\end_inset


\end_layout

\begin_layout Standard
Given an abstraction of a game structure induced by a set of predicates,
 one can compute may and must relations defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Abstractions-of-games"

\end_inset

 (
\begin_inset Formula $\Delta_{c}^{m}$
\end_inset

, 
\begin_inset Formula $\Delta_{c}^{M}$
\end_inset

, 
\begin_inset Formula $\Delta_{u}^{m}$
\end_inset

, 
\begin_inset Formula $\Delta_{u}^{M}$
\end_inset

, 
\begin_inset Formula $\gamma_{u}^{m}$
\end_inset

, 
\begin_inset Formula $\gamma_{c}^{M}$
\end_inset

, 
\begin_inset Formula $Avl$
\end_inset

); however doing so may be computationally hard for complex specifications
 and for a large number of predicates.
 Therefore, we compute and refine approximate versions of these relations
 instead.
 We introduce two sources of imprecision.
 First, we decompose complex syntactic transitions into simpler 
\emph on
atomic transitions 
\emph default
that are abstracted and refined individually.
 The granularity of decomposition can vary and will be selected experimentally.
 Some possible choices include abstracting away individual statements, basic
 blocks, groups of basic blocks, etc.
 We introduce additional 
\emph on
temporary predicates
\emph default
 at the boundaries of atomic transitions and we abstract each atomic transition
 wrt predicates at the program points preceeding and following the transition.
\end_layout

\begin_layout Standard
Second, in computing may and must abstractions of an atomic transition,
 we can sacrifice further precision for performance by computing approximate
 abstraction instead of precise (wrt to the given set of predicates) boolean
 abstraction of the transition.
 For example, the may-overapproximation of the transition relation can be
 computed using Cartesian abstraction
\begin_inset CommandInset citation
LatexCommand cite
key "Ball_PR_2001"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Decomposing syntactic transitions
\end_layout

\begin_layout Standard
We represent decomposition of a syntactic transition into atomic transitions
 using modified grammar: 
\begin_inset Formula 
\[
dtran:\,\, atran\mid or(dtran*)\mid seq(dtran*)
\]

\end_inset

where 
\begin_inset Formula $atran\in Trans(X,Y,T)$
\end_inset

 is an atomic transition.
 
\end_layout

\begin_layout Standard
We introduce a set of extra temporary predicates that capture relations
 among program variables in intermediate states of the transition:
\end_layout

\begin_layout Itemize

\emph on
temporary predicates 
\emph default

\begin_inset Formula $P_{T}=\{\tau_{1},\ldots,\tau_{h}\}$
\end_inset

, 
\begin_inset Formula $\tau_{i}\in Pred(X\cup Y\cup T\cup X')$
\end_inset

.
\end_layout

\begin_layout Standard
We label each node in the syntax tree with two (potentially overlapping)
 sets of predicates: pre-predicates and post-predicates.
 We write 
\begin_inset Formula $pre:t:post$
\end_inset

, where 
\begin_inset Formula $pre,post\in(P_{S}\cup P_{L}\cup P_{T})^{*}$
\end_inset

 for a transition 
\begin_inset Formula $t$
\end_inset

 annotated with pre-predicates 
\begin_inset Formula $pre$
\end_inset

 and post-predicates 
\begin_inset Formula $post$
\end_inset

.
 A valid labelling must satisfy the following consistency criteria:
\end_layout

\begin_layout Itemize
an or-node 
\begin_inset Formula $pre:or(pre^{1}:t^{1}:post^{1},\ldots,pre^{n}:t^{n}:post^{n}):post$
\end_inset

 must satisfy: 
\begin_inset Formula $\bigwedge_{i=1\ldots n}(post^{i}=post)$
\end_inset

 and 
\begin_inset Formula $\bigwedge_{i=1\ldots n}(pre^{i}\subseteq pre)$
\end_inset

.
\end_layout

\begin_layout Itemize
a seq-node 
\begin_inset Formula $pre:seq(pre^{1}:t^{1}:post^{1},\ldots,pre^{n}:t^{n}:post^{n}):post$
\end_inset

 must satisfy: 
\begin_inset Formula $(pre=pre^{1})\land(post=post^{n})\land\bigwedge_{i=1\ldots n-1}(post^{i}=pre^{i+1})$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Abstracting atomic transitions
\end_layout

\begin_layout Standard
Given an atomic transition 
\begin_inset Formula $t$
\end_inset

, a set of pre-predicates 
\begin_inset Formula $pre=\{\pi_{1},\ldots,\pi_{p}\}$
\end_inset

, and a set of post-predicates 
\begin_inset Formula $post=\{\nu_{1},\ldots,\nu_{q}\}$
\end_inset

, we denote 
\begin_inset Formula $V(pre)$
\end_inset

 the set of variables involved in predicates in 
\begin_inset Formula $pre$
\end_inset

, and 
\begin_inset Formula $V(post)$
\end_inset

 the set of variables involved in predicates in 
\begin_inset Formula $post$
\end_inset

 .
 Precise may and must abstractions of 
\begin_inset Formula $t$
\end_inset

 wrt 
\begin_inset Formula $pre$
\end_inset

 and 
\begin_inset Formula $post$
\end_inset

 can be computed as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\rho^{m}(pre,t,post)=\{(b,c)\in\mathbb{B}^{p}\times\mathbb{B}^{q}\mid\exists V(pre),V(post).\,\delta(t)\land(\bar{\pi}=b)\land(\bar{\nu}=c)\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\rho^{M}(pre,t,post)=\{(b,c)\in\mathbb{B}^{p}\times\mathbb{B}^{q}\mid\forall V(pre).\,(\bar{\pi}=b)\implies\exists V(post)\setminus V(pre).\,\delta(t)\land(\bar{\nu}=c)\}
\]

\end_inset

We extend 
\begin_inset Formula $\rho^{m}$
\end_inset

 and 
\begin_inset Formula $\rho^{M}$
\end_inset

 to non-atomic transitions as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\rho^{m}(pre,seq(pre^{i}:t^{i}:post^{i},i=1\ldots n),post)=\{(b^{1},b^{n})\mid\exists b^{2}\ldots b^{n-1}.\,\bigwedge_{i=1\ldots n}(b^{i},b^{i+1})\in\rho^{m}(pre^{i},t^{i},post^{i})\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\rho^{M}(pre,seq(pre^{i}:t^{i}:post^{i},i=1\ldots n),post)=\{(b^{1},b^{n})\mid\exists b^{2}\ldots b^{n-1}.\,\bigwedge_{i=1\ldots n}(b^{i},b^{i+1})\in\rho^{M}(pre^{i},t^{i},post^{i})\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\rho^{m}(pre,or(pre^{i}:t^{i}:post,i=1\ldots n),post)=\bigcup_{i=1\ldots n}\rho^{m}(pre^{i},t^{i},post)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\rho^{M}(pre,or(pre^{i}:t^{i}:post,i=1\ldots n),post)=\bigcup_{i=1\ldots n}\rho^{M}(pre^{i},t^{i},post)
\]

\end_inset


\end_layout

\begin_layout Standard
In practice, it may be easier to compute approximate versions of these transitio
n relations 
\begin_inset Formula $\rho^{m+}(pre,t,post)\supseteq\rho^{m}(pre,t,post)$
\end_inset

 and 
\begin_inset Formula $\rho^{M-}(pre,t,post)\subseteq\rho^{M}(pre,t,post)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Computing initial abstraction
\begin_inset CommandInset label
LatexCommand label
name "sub:Computing-initial-abstraction"

\end_inset


\end_layout

\begin_layout Standard
Before computing initial abstraction of game structure 
\begin_inset Formula $SG=\langle X,Y,T,init,ctran,utran\rangle$
\end_inset

, the following pre-processing steps are performed:
\end_layout

\begin_layout Itemize
Controllable transitions are extended to explicitly assign all next-state
 variables 
\begin_inset Formula $ctran'=\{Ext(X,t)\mid t\in ctran\}$
\end_inset

, 
\begin_inset Formula $ctran'\subseteq Trans(X,Y,T)$
\end_inset

.
\end_layout

\begin_layout Itemize
Uncontrollable transitions are extended to explicitly assign all next-state
 and label variables: 
\begin_inset Formula $utran'=\{Ext(X\cup Y,t)\mid t\in utran\}$
\end_inset

, 
\begin_inset Formula $utran'\subseteq Trans(X\cup Y,\emptyset,T)$
\end_inset

.
 Label variables are treated as state variables in uncontrollable transitions,
 because we want to track how these transitions update label predicates.
\end_layout

\begin_layout Itemize
Transitions in 
\begin_inset Formula $ctran'$
\end_inset

 and 
\begin_inset Formula $utran'$
\end_inset

 are decomposed into atomic transitions and annotated with initial predicates.
 The initial set of predicates can be computed for instance using syntactic
 program analysis
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Namjoshi_K_00"

\end_inset

.
 Annotations must satisfy the following additional requirements:
\end_layout

\begin_deeper
\begin_layout Itemize
For a controllable transition 
\begin_inset Formula $t\in ctran'$
\end_inset

, the root of the annotated syntax tree must be in the form 
\begin_inset Formula $(P_{S}\cup P_{L}):t:P_{S}'$
\end_inset

, i.e., the set of pre-predicates of the transition must include all state
 and label predicates, and the set of post-predicates of the transition
 must include all primed versions of state predicates.
\end_layout

\begin_layout Itemize
For an uncontrollable transition 
\begin_inset Formula $t\in utran'$
\end_inset

, the root of the annotated syntax tree must be in the form 
\begin_inset Formula $(P_{S}\cup P_{L}):t:(P_{S}'\cup P_{L}')$
\end_inset

, i.e., post-predicates of the transition include primed versions of both
 state and label predicates.
\end_layout

\end_deeper
\begin_layout Standard
We can now compute initial abstract transition relations:
\begin_inset Formula 
\[
\Delta_{c}^{m+}=\bigcup_{t\in ctran'}\rho^{m+}(P_{S}\cup P_{L},t,P_{S}')
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Delta_{c}^{M-}=\bigcup_{t\in ctran'}\rho^{M-}(P_{S}\cup P_{L},t,P_{S}')
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\gamma_{u}^{m+}=\bigcup_{t\in utran'}\rho^{m+}(P_{S}\cup P_{L},t,P_{S}'\cup P_{L}')
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\gamma_{u}^{M-}=\bigcup_{t\in utran'}\rho^{M-}(P_{S}\cup P_{L},t,P_{S}'\cup P_{L}')
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Delta_{u}^{m+}=\{(b,b')\in\mathbb{B}^{k}\times\mathbb{B}^{k}\mid\exists c,c'\in\mathbb{B}^{m}.\,((b,c),(b',c'))\in\gamma_{u}^{m+}\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Delta_{u}^{M-}=\{(b,b')\in\mathbb{B}^{k}\times\mathbb{B}^{k}\mid\exists c,c'\in\mathbb{B}^{m}.\,((b,c),(b',c'))\in\gamma_{u}^{M-}\}
\]

\end_inset


\end_layout

\begin_layout Standard
Next, we need to compute the 
\begin_inset Formula $Avl$
\end_inset

 relation that consists of sets of extended abstract states.
 Arbitrary sets of extended abstract states cannot be efficiently represented
 symbolically.
 Therefore, we only consider cubes of the form 
\begin_inset Formula $Cube(d_{1},\ldots,d_{k},en_{1},\ldots,en_{m},f_{1},\ldots,f_{m})=\{(b_{1},\ldots,b_{k},c_{1},\ldots,c_{m})\mid\bigwedge_{i=1\ldots k}(b_{i}=d_{i})\land\bigwedge_{i=1\ldots m}en_{i}\implies(c_{i}=f_{i})\}$
\end_inset

.
 A cube describes a set of extended abstract states where a subset of label
 predicates are assigned fixed values.
 The 
\begin_inset Formula $en_{i}\in\mathbb{B}$
\end_inset

 parameters indicate which label predicates are fixed in the cube; 
\begin_inset Formula $f_{i}\in\mathbb{B}$
\end_inset

 specify values of these predicates.
 A set of cubes can be symbolically represented using 
\begin_inset Formula $m$
\end_inset

 extra variables that store 
\begin_inset Formula $en_{i}$
\end_inset

 values.
\end_layout

\begin_layout Standard
Initial abstraction of the game includes sets of cubes 
\begin_inset Formula $Avl^{+}$
\end_inset

 and 
\begin_inset Formula $Avl^{-}$
\end_inset

 that approximate the 
\begin_inset Formula $Avl$
\end_inset

 relation such that 
\begin_inset Formula $Avl^{-}\subseteq Avl$
\end_inset

, 
\begin_inset Formula $Avl^{-}\subseteq Avl^{+}$
\end_inset

, and 
\begin_inset Formula $\forall\alpha\in Avl.\exists\beta\in Avl^{+},\alpha\subseteq\beta$
\end_inset

.
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout

\series bold
TODO
\series default
: give an example of how 
\begin_inset Formula $Avl^{+/-}$
\end_inset

 can be computed.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Formulas
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cprecm"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cprecM"

\end_inset

 for computing 
\begin_inset Formula $Cpre_{c}^{m}$
\end_inset

 and 
\begin_inset Formula $Cpre_{c}^{M}$
\end_inset

 contain quantifiers over set variable 
\begin_inset Formula $\alpha$
\end_inset

.
 Given a symbolic representation of 
\begin_inset Formula $Avl^{+/-}$
\end_inset

 as sets of cubes, this operation can be performed symbolically using modified
 versions of 
\begin_inset Formula $Cpre$
\end_inset

 operator 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{c}^{m}(U)=\{v\in\Sigma\mid\exists\alpha\in Avl^{+}(v).\exists a\in\Lambda.in(\alpha,a)\land\forall a'\in(\gamma_{u}^{M-})^{*}(a).\Delta_{c}^{m+}(a')\cap U\neq\emptyset\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Cpre_{c}^{M}(U)=\{v\in\Sigma\mid\exists\alpha\in Avl^{-}(v).\forall a\in\Lambda.\, in(\alpha,a)\implies\forall a'\in(\gamma_{u}^{m+})^{*}(a).\Delta_{c}^{M-}(a')\cap U\neq\emptyset\}
\]

\end_inset

where the set membership check 
\begin_inset Formula $a\in\alpha$
\end_inset

 is replaced with the 
\begin_inset Formula $in(a,\alpha)$
\end_inset

 function, 
\begin_inset Formula $in:\mathbb{B}^{k+2m}\times\mathbb{B}^{k+m}\rightarrow\mathbb{B}$
\end_inset

, defined as follows: 
\begin_inset Formula $in((d_{1},\ldots,d_{k},en_{1},\ldots,en_{m},f_{1},\ldots,f_{m}),(b_{1},\ldots,b_{k},c_{1},\ldots,c_{m}))=(\bigwedge_{i=1\ldots k}d_{i}=b_{i})\land(\bigwedge_{i=1\ldots m}en_{i}\implies(f_{i}=c_{i}))$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Adding spurious/missing transition
\end_layout

\begin_layout Plain Layout
Adding pre-/post-predicate
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Identifying transition segments.
\end_layout

\begin_layout Plain Layout
Non-blocking assignments
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Refinement
\end_layout

\begin_layout Standard
The abstraction refinement algorithm described in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Abstraction-refinement"

\end_inset

 involves a number of checks and partitioning operations.
 We describe how these operations can be efficiently performed for symbolic
 abstract games.
\end_layout

\begin_layout Itemize
Cases 1.1.1/1.1.2 require checking that 
\begin_inset Formula $\alpha\in Avl(v)$
\end_inset

, where 
\begin_inset Formula $v=(d_{1},\ldots,d_{k})$
\end_inset

, 
\begin_inset Formula $\alpha=Cube(d_{1},\ldots,d_{k},en_{1},\ldots,en_{m},f_{1},\ldots,f_{m})$
\end_inset

.
 While we do not compute the precise set 
\begin_inset Formula $Avl(v)$
\end_inset

, the membership check can be performed by using an SMT solver to check
 satisfiability of the formula
\begin_inset Formula $\forall s\in\|v\|_{\Sigma}.\exists a\in\Lambda,l\in L.(in(\alpha,a)\land(s,l)\in\|a\|_{\Lambda})$
\end_inset

.
\end_layout

\begin_layout Itemize
Case 1.2 computes
\begin_inset Formula $\hat{\alpha}=\{a\in\alpha|\forall a'\in(\gamma_{u}^{M-})^{*}(a).\Delta_{c}^{m+}(a')\cap W^{M}\neq\emptyset\}$
\end_inset

.
 This computation can be carried out symbolically by using the 
\begin_inset Formula $in$
\end_inset

 function to perform the set membership check:
\begin_inset Formula $\hat{\alpha}=\{a\in\Lambda|in(\alpha,a)\forall a'\in(\gamma_{u}^{M-})^{*}(a).\Delta_{c}^{m+}(a')\cap W^{M}\neq\emptyset\}$
\end_inset

.
\end_layout

\begin_layout Itemize
Case 1.2.1: Refine 
\begin_inset Formula $v$
\end_inset

 by partitioning it into 2 or more states 
\begin_inset Formula $\{v_{1},\ldots,v_{k}\}$
\end_inset

 such that 
\begin_inset Formula $\exists\alpha'\in Avl(v_{1}).\,\alpha'\subseteq\hat{\alpha}$
\end_inset

.
 At this point 
\begin_inset Formula $\hat{\alpha}$
\end_inset

 is symbolically represented as a set of extended abstract states.
 Since we cannot handle arbitrary sets, we find a maximal cube 
\begin_inset Formula $\alpha'\subseteq\alpha$
\end_inset

, 
\begin_inset Formula $\alpha'=Cube(d_{1},\ldots,d_{k},en_{1},\ldots,en_{m},f_{1},\ldots,f_{m})$
\end_inset

 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
(does it make sense to find all maximal cubes and pick the best one using
 some criterion?)
\end_layout

\end_inset

 and compute the set of concrete states 
\begin_inset Formula $\varphi(X)=\{s\in D(X)\mid\bigwedge_{i=1\ldots k}\sigma_{i}(s)=d_{i}\land\exists l\in L.(s,l).\bigwedge_{i.en_{i}=1}(\lambda_{i}(s,l)=f_{i})\}$
\end_inset

.
 This computation relies on a 
\emph on
quantifier elimination
\emph default
 procedure and returns a formula over concrete state variables 
\begin_inset Formula $X$
\end_inset

.
 We refine the set of state predicates 
\begin_inset Formula $P_{S}$
\end_inset

 using new predicates in 
\begin_inset Formula $\varphi$
\end_inset

: 
\begin_inset Formula $P_{S}:=massage(P_{S},\varphi)$
\end_inset

, where the 
\begin_inset Formula $massage$
\end_inset

 operation simplifies 
\begin_inset Formula $\varphi$
\end_inset

 and extracts new predicates that are not implied by predicates already
 in 
\begin_inset Formula $P_{S}$
\end_inset

 and returns the updates set of predicates.
 Abstract transition relations of the game are then recomputed with the
 new set of predicates.
\end_layout

\begin_layout Itemize
Case 1.2.2: 
\begin_inset Formula $\check{\alpha}=\emptyset$
\end_inset

, i.e., all extended abstract states in 
\begin_inset Formula $\alpha$
\end_inset

 are may-winning; however 
\begin_inset Formula $\alpha$
\end_inset

 is not must-winning, i.e., 
\begin_inset Formula $\exists a\in\alpha.\exists a'\in(\gamma_{u}^{m+})^{*}(a).\Delta_{c}^{M-}(a')\cap W^{M}=\emptyset$
\end_inset

.
\end_layout

\begin_layout Itemize
Cases 1.2.2.1 and 1.2.2.2 and Case 2 are similar and can be handled analogously.
 In both cases we have a may-plus transition between two abstract states
 but no must-minus transition between the same states, and we need to refine
 the transition relations and, possibly, the abstract states to reduce the
 gap between may and must transition relations.
 
\end_layout

\begin_deeper
\begin_layout Standard
Assume that the abstract states in question are 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $a'$
\end_inset

.
 
\begin_inset Formula $a$
\end_inset

 is defined over predicates 
\begin_inset Formula $pre=\{\pi_{1},\ldots,\pi_{n}\}\in Pred(Z)^{n}$
\end_inset

 over concrete variables 
\begin_inset Formula $Z$
\end_inset

.
 
\begin_inset Formula $a'$
\end_inset

 is defined over predicates 
\begin_inset Formula $post=\{\nu_{1},\ldots,\nu_{l})\}\in Pred(Q)^{l}$
\end_inset

 over concrete variables 
\begin_inset Formula $Q$
\end_inset

.
 The abstract transition relations are 
\begin_inset Formula $\Delta^{m+},\Delta^{M-}\subseteq\mathbb{B}^{n}\times\mathbb{B}^{l}$
\end_inset

, 
\begin_inset Formula $(a,a')\in\Delta^{m+}$
\end_inset

 and 
\begin_inset Formula $(a,a')\notin\Delta^{M-}$
\end_inset

.
 Since 
\begin_inset Formula $\Delta^{m+}$
\end_inset

 is computed as a uninon of abstract (controllable or uncontrollable) transition
 relations for individual syntactic transitions (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Computing-initial-abstraction"

\end_inset

), there exists a syntactic transiton 
\begin_inset Formula $t$
\end_inset

 such that 
\begin_inset Formula $(a,a')\in\rho^{m+}(pre,t,post)$
\end_inset

, 
\begin_inset Formula $(a,a')\notin\rho^{M-}(pre,t,post)$
\end_inset

.
 The transition relation 
\begin_inset Formula $\rho^{m+}(pre,t,post)$
\end_inset

 is, in turn, composed of atomic syntactic transition relations.
 We can find at least one sequence of atomic may-transitions connecting
 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $a'$
\end_inset

 through a chain of intermediate abstract states 
\begin_inset Formula $(a_{1}=a),a_{2},\ldots,(a_{j}=a')$
\end_inset

 as shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Refining-a-spurious"

\end_inset

.
 We refine this sequence of transitions and intermediate states as follows.
\end_layout

\begin_layout Itemize
First, we check each individual atomic transition 
\begin_inset Formula $(a_{i},a_{i+1})\in\rho^{m+}(P_{i},t_{i},P_{i+1})$
\end_inset

.
 If the transition is a spurious may-transition, i.e., 
\begin_inset Formula $(a_{i},a_{i+1})\in\rho^{m}(P_{i},t_{i},P_{i+1})$
\end_inset

 then we refine 
\begin_inset Formula $\rho^{m+}(P_{i},t_{i},P_{i+1}):=\rho^{m+}(P_{i},t_{i},P_{i+1})\setminus\{(a_{i},a_{i+1})\}$
\end_inset

.
 If 
\begin_inset Formula $(a,a')$
\end_inset

 is also a valid must-transition, i.e., 
\begin_inset Formula $(a_{i},a_{i+1})\in\rho^{M}(P_{i},t_{i},P_{i+1})$
\end_inset

, but 
\begin_inset Formula $(a_{i},a_{i+1})\notin\rho^{M-}(P_{i},t_{i},P_{i+1})$
\end_inset

, then we refine 
\begin_inset Formula $\rho^{M-}(P_{i},t_{i},P_{i+1}):=\rho^{M-}(P_{i},t_{i},P_{i+1})\cup\{(a_{i},a_{i+1})\}$
\end_inset

.
 Each of the two checks can be performed by a single SMT query.
\end_layout

\begin_layout Itemize
If the previous step did not refine the transition, then we partition 
\begin_inset Formula $a$
\end_inset

 into 
\begin_inset Formula $\check{a}$
\end_inset

 and 
\begin_inset Formula $\hat{a}$
\end_inset

, so that 
\begin_inset Formula $\forall s\in\|\check{a}\|.\,(\delta(t_{1})\circ\ldots\circ\delta(t_{j-1}))(s)\cap\|a'\|=\emptyset$
\end_inset

.
 To this end, we find a single state 
\begin_inset Formula $s$
\end_inset

 that satisfies this constraint.
 We construct an explanation of unreachability of 
\begin_inset Formula $a'$
\end_inset

 from 
\begin_inset Formula $s$
\end_inset

 and extract new predicates from this explanation.
 The state 
\begin_inset Formula $s$
\end_inset

 can be found by solving the equation 
\begin_inset Formula $s\in wp(\ldots wp(wp(\|a_{j}\|,t_{j-1})\cap\|a_{j-1}\|,t_{j-2})\cap\|a_{j-2}\|\ldots,t_{1})\cap\|a_{1}\|$
\end_inset

, where the second conjunct is the weakest precondition of the abstract
 state 
\begin_inset Formula $a'$
\end_inset

with respect to the chain of atomic transitions 
\begin_inset Formula $t_{1}\ldots t_{j-1}$
\end_inset

.
 Weakest precondition can be computed syntactically.
 If there exists 
\begin_inset Formula $s$
\end_inset

 that satisfies this equation, we can use it to construct an unsatisfiable
 formula: 
\begin_inset Formula $(Z=s)\land\bigwedge_{i=1\ldots(j-1)}\delta(t_{i})\land\bigwedge_{i=2\ldots j}(V(P_{i})\in\|a_{i}\|)$
\end_inset

.
 We generate 
\begin_inset Formula $j-1$
\end_inset

 partitionings of the formula into a prefix formula 
\begin_inset Formula $Pref_{q}=(Z=s)\land\bigwedge_{i=1\ldots(q-1)}\delta(t_{i})\land\bigwedge_{i=2\ldots q}(V(P_{i})\in\|a_{i}\|)$
\end_inset

 and suffix formula 
\begin_inset Formula $Suf_{q}=\bigwedge_{i=q\ldots(j-1)}\delta(t_{i})\land\bigwedge_{i=(q+1)\ldots j}(V(P_{i})\in\|a_{i}\|)$
\end_inset

, for 
\begin_inset Formula $q=1\ldots(j-1)$
\end_inset

.
 We compute a Craig interpolant of each pair 
\begin_inset Formula $Pref_{q}$
\end_inset

, 
\begin_inset Formula $Suf_{q}$
\end_inset

 and extract a set of new predicates from the interpolant.
 These predicates are relevant to proving the infeasibility of the transition
 
\begin_inset Formula $(a,a')$
\end_inset

 at location 
\begin_inset Formula $q$
\end_inset

 in the path.
 We update the labelling of the syntax tree of transition 
\begin_inset Formula $t$
\end_inset

 adding the new predicates at relevant locations.
\end_layout

\begin_layout Itemize
If a state 
\begin_inset Formula $s$
\end_inset

 could not be found at the previous step, then 
\begin_inset Formula $(a,a')\in\rho^{M}(t)$
\end_inset

 and we need to refine intermediate states 
\begin_inset Formula $a_{i}$
\end_inset

 to obtain a chain of must-transitions from 
\begin_inset Formula $a$
\end_inset

 to 
\begin_inset Formula $a'$
\end_inset

.
 To this end, we explore the path 
\begin_inset Formula $a_{1},a_{2},\ldots,a_{j}$
\end_inset

 backwards, computing the precise must-predecessor on each step.
 Denote 
\begin_inset Formula $a_{i}^{M}$
\end_inset

 the subset of states in 
\begin_inset Formula $\|a_{i}\|$
\end_inset

 from which there exists a concrete transition to 
\begin_inset Formula $\|a_{j}\|$
\end_inset

.
 Then 
\begin_inset Formula $a_{j}^{M}=\|a_{j}\|$
\end_inset

.
 For 
\begin_inset Formula $i<j$
\end_inset

, 
\begin_inset Formula $a_{i}^{M}$
\end_inset

 is computed as 
\begin_inset Formula $a_{i}^{M}=wp(a_{i+1}^{M},t_{i})\cap\|a_{i}\|$
\end_inset

, where 
\begin_inset Formula $wp(a_{i+1}^{M},t_{i})$
\end_inset

 is the weakest precondition of 
\begin_inset Formula $a_{i+1}^{M}$
\end_inset

 with respect to atomic transition 
\begin_inset Formula $t_{i}$
\end_inset

.
 For each satisfiable 
\begin_inset Formula $a_{i}^{M}$
\end_inset

, we refine the set of predicates in the corresponding location: 
\begin_inset Formula $P_{i}:=massage(P_{i},a_{i}^{M})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
If the above algorithm is wrong for some reason, here is another approach:
\end_layout

\begin_layout Plain Layout
We refine this sequence of transitions and intermediate states as follows.
 
\end_layout

\begin_layout Itemize
First, we check the feasibility of each transition 
\begin_inset Formula $(a_{i},a_{i+1})$
\end_inset

 in the path, i.e.
 
\begin_inset Formula $(a_{i},a_{i+1})\in\rho^{m}(P_{i},t_{i},P_{i+1})$
\end_inset

 for all 
\begin_inset Formula $i=1\ldots(j-1)$
\end_inset

.
 To this end, we check the satisfiability of the formula
\begin_inset Formula $\delta(t_{i})\land(V(P_{i})\in\|a_{i}\|)\land(V(P_{i+1})\in\|a_{i+1}\|)$
\end_inset

.
 If we discover that one of the transitions is not feasible, we refine 
\begin_inset Formula $\rho^{m+}(P_{i},t_{i},P_{i+1}):=\rho^{m+}(P_{i},t_{i},P_{i+1})\setminus\{(a_{i},a_{i+1})\}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Otherwise, we check whether the entire path 
\begin_inset Formula $a_{1},a_{2},\ldots,a_{j}$
\end_inset

 is feasible, i.e., whether there exists a transition 
\begin_inset Formula $(a,a')\in\Delta^{m}$
\end_inset

 through intermediate states 
\begin_inset Formula $a_{i}$
\end_inset

.
 To this end, we check the satisfiability of the formula 
\begin_inset Formula $\bigwedge_{i=1\ldots(j-1)}\delta(t_{i})\land\bigwedge_{i=1\ldots j}(V(P_{i})\in\|a_{i}\|)$
\end_inset

.
 In case the formula is unsatisfiable, then we generate 
\begin_inset Formula $j-1$
\end_inset

 partitionings of the formula into a prefix formula 
\begin_inset Formula $Pref_{q}=\bigwedge_{i=1\ldots(q-1)}\delta(t_{i})\land\bigwedge_{i=1\ldots q}(V(P_{i})\in\|a_{i}\|)$
\end_inset

 and suffix formula 
\begin_inset Formula $Suf_{q}=\bigwedge_{i=q\ldots(j-1)}\delta(t_{i})\land\bigwedge_{i=(q+1)\ldots j}(V(P_{i})\in\|a_{i}\|)$
\end_inset

, for 
\begin_inset Formula $q=1\ldots(j-1)$
\end_inset

.
 We compute a Craig interpolant of each pair 
\begin_inset Formula $Pref_{q}$
\end_inset

, 
\begin_inset Formula $Suf_{q}$
\end_inset

 and extract a set of new predicates from the interpolant.
 These predicates are relevant to proving the infeasibility of the transition
 
\begin_inset Formula $(a,a')$
\end_inset

 at location 
\begin_inset Formula $q$
\end_inset

 in the path.
 We update the labelling of the syntax tree of transition 
\begin_inset Formula $t$
\end_inset

 adding the new predicates at relevant locations.
\end_layout

\begin_layout Itemize
Otherwise (i.e., the path 
\begin_inset Formula $a_{1},a_{2},\ldots,a_{j}$
\end_inset

 is feasible), for each transition 
\begin_inset Formula $(a_{i},a_{i+1})\in\rho^{m+}(P_{i},t_{i},P_{i+1})$
\end_inset

 in the path, such that 
\begin_inset Formula $(a_{i},a_{i+1})\notin\rho^{M-}(P_{i},t_{i},P_{i+1})$
\end_inset

 we check whether 
\begin_inset Formula $(a_{i},a_{i+1})\in\rho^{M}(P_{i},t_{i},P_{i+1})$
\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
TODO:
\series default
 Optimisation: do the check for all 
\begin_inset Formula $a\in\alpha$
\end_inset


\end_layout

\end_inset

.
 If so, we refine 
\begin_inset Formula $\rho^{M-}(P_{i},t_{i},P_{i+1}):=\rho^{M-}(P_{i},t_{i},P_{i+1})\cup\{(a_{i},a_{i+1})\}$
\end_inset

.
 If all transitions in the chain can be upgraded to must-transitions in
 this way, then 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(a,a')\in\rho^{M-}(pre,t,post)$
\end_inset

 will hold for the new top-level transition relation.
\end_layout

\begin_layout Itemize
If none of the previous special cases helped to refine the transition, we
 explore the path 
\begin_inset Formula $a_{1},a_{2},\ldots,a_{j}$
\end_inset

 backwards, computing the precise must-predecessor on each step.
 Denote 
\begin_inset Formula $a_{i}^{M}$
\end_inset

 the subset of states in 
\begin_inset Formula $\|a_{i}\|$
\end_inset

 from which there exists a concrete transition to 
\begin_inset Formula $\|a_{j}\|$
\end_inset

.
 Then 
\begin_inset Formula $a_{j}^{M}=\|a_{j}\|$
\end_inset

.
 For 
\begin_inset Formula $i<j$
\end_inset

, 
\begin_inset Formula $a_{i}^{M}$
\end_inset

 can be computed as 
\begin_inset Formula $a_{i}^{M}=wp(a_{i+1}^{M},t_{i})\cap\|a_{i}\|$
\end_inset

, where 
\begin_inset Formula $wp(a_{i+1}^{M},t_{i})$
\end_inset

 is the weakest precondition of 
\begin_inset Formula $a_{i+1}^{M}$
\end_inset

 with respect to atomic transition 
\begin_inset Formula $t_{i}$
\end_inset

.
 Weakest precondition can be computed syntactically.
 We iteratively compute 
\begin_inset Formula $a_{i}^{M}$
\end_inset

 for decreasing values of 
\begin_inset Formula $i$
\end_inset

 until 
\begin_inset Formula $i=1$
\end_inset

 or 
\begin_inset Formula $a_{i}^{M}$
\end_inset

 becomes unsatisfiable.
 For each satisfiable 
\begin_inset Formula $a_{i}^{M}$
\end_inset

, we refine the set of predicates in the corresponding location: 
\begin_inset Formula $P_{i}:=massage(P_{i},a_{i}^{M})$
\end_inset

.
\end_layout

\end_deeper
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename refine.eps
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Refining-a-spurious"

\end_inset

Refining a spurious may-transition
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
TODO:
\series default
 Recomputing abstraction with new state predicates.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "extra"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
